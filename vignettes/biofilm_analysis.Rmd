---
title: "Vignette title"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  This is the abstract.
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r knitrOpts, include=FALSE}
# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = FALSE,
                      warning = TRUE, 
                      message = TRUE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")

# check for installation of packages requires to knit this vignette
req_pkgs <- c("BiocStyle", "ggpubr", "stringi", "DT")

check_pkgs <- function(x) {
  if(!requireNamespace(x, quietly = TRUE)) {
    stop(paste0("The package ",
                paste0(x),
                " is required to knit this document. 
                Please install it."))
  }
}

lapply(req_pkgs, check_pkgs)
```

# Preface

## Introduction

This vignette outlines the method used to analyse the label-free quantitative 
LC-MS/MS data obtained for _C. albicans_ (strain DAY286 biofilm) 
extracellular vesicles (EVs) and whole cell lysates (WCL) by Dawson et 
al. (2019). The tools provided in this package, `r Githubpkg("csdaw/candidaev")`
, allows the step-by-step reproduction of the results presented in the paper. 
The manuscript in its submitted form and the `.Rmarkdown` file used to 
generate it can found 
[here](https://github.com/csdaw/candidaev/tree/master/manuscript).

The analysis workflow used in this vignette is derived from the excellent 
**Bioconductor** package `r Biocpkg("DEP")`[^1]. Furthermore, some of the 
plotting functions available in `r Biocpkg("DEP")` have been modified for use 
in this package, `r Githubpkg("csdaw/candidaev")`. 

[^1]: Zhang, X., Smits, A. H., van Tilburg, G. B. A., Ovaa, H., Huber, W., & 
Vermeulen, M. (2018). Proteome-wide identification of ubiquitin interactions 
using UbIA-MS. _Nature Protocols, 13_(3), 530-550. 
[doi:10.1038/nprot.2017.147](https://doi.org/10.1038/nprot.2017.147)

## Experimental design

Extracellular vesicles (EVs) were isolated using differential 
ultracentrifugation from _C. albicans_ biofilms grown using the lab strain 
DAY286 (n = 5). Additionally, scrapings were taken from the biofilms 
and the collected cells were lysed to generate whole cell lysates (WCL). 
Each EV biological replicate was paired with a WCL replicate as they were
derived from the same biofilm.

Samples analysed in this vignette:

* DAY286 Biofilm EV1
* DAY286 Biofilm EV2
* DAY286 Biofilm EV3
* DAY286 Biofilm EV4
* DAY286 Biofilm EV5
* DAY286 Biofilm WCL1 (W1)
* DAY286 Biofilm WCL2 (W2)
* DAY286 Biofilm WCL3 (W3)
* DAY286 Biofilm WCL4 (W4)
* DAY286 Biofilm WCL5 (W5)

These samples were electrophoresed and the SDS-PAGE gel slices were 
reduced, alkylated, and digested with trypsin. The resulting peptides were 
extracted with acetonitrile, analysed by nano-LC-ESI-MS/MS, identified using 
MaxQuant, and quantified via the MaxLFQ algorithm in MaxQuant. 
The `proteinGroups.txt` file output was used for subsequent analyses.

## Data availability

The raw data was searched against the _C. albicans_ (SC5314) UniProt 
reference proteome (UP000000559) using MaxQuant version 1.6.0.16.  The 
`proteinGroups.txt` file analysed in this vignette 
can be easily accessed 
[here](https://github.com/csdaw/candidaev/tree/master/data-raw/lcms). 
It is also installed along with the 
`r Githubpkg("csdaw/candidaev")` package and can be loaded in R with 

```
data(biofilm)
```

The LC-MS/MS raw data, peak data, and results files have been 
deposited in the ProteomeXchange Consortium database via the PRIDE partner 
repository with the data set identifier y and DOI x. 

# Data analysis

## Setup

The packages required for the analyses are loaded and a specific 
seed is set for the steps requiring random number generation (imputation 
and clustering).

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
# load packages
library(candidaev)
library(dplyr)
library(ggplot2)

# set seed for imputation, kmeans, MDS plot
set.seed(1)
```

To reproduce the results exactly as they are in Dawson et al. (2019), the 
following code block is run to perform a specific number of draws from 
a random distribution before performing the analysis of the `biofilm` data. 
Otherwise, the results will be extremely similar but not identical to Dawson 
et al. (2019).

```{r randomDraws, echo=TRUE}
# for results to be reproducible in seperate documents
# need to use set.seed AND need to perform same number of 
# 'random' draws in the same order as manuscript.Rmd

# DAY286 yeast
yeast_lfq <- yeast %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., yeast_exp)

yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_1")]

yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- limma::normalizeCyclicLoess(yeast_filt2)

yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both) # first set of random draws
```

## Exploring the `biofilm` data set

As above, the _C. albicans_ DAY286 biofilm LC-MS/MS data set is provided as a 
data.frame called `biofilm` in this package. 
It has `r nrow(biofilm)` rows each of which corresponds to a single protein 
group[^2], and `r ncol(biofilm)` columns. 
A key describing most of these columns can be found in the 
[MaxQuant documentation](http://www.coxdocs.org/doku.php?id=maxquant:table:proteingrouptable). 
The `LFQ.intensity` columns hold the protein quantification data that is 
used for the following analyses.

[^2]: Each protein group comprises the group of proteins that could be 
reconstructed from a set of peptides by MaxQuant. In most cases this will be 
a single protein but sometimes there will be two or more proteins that 
could not be distinguished by the set of peptides.

```{r bColumns, echo=TRUE}
colnames(biofilm)
```

`biofilm_exp` is another data.frame provided in this package. It 
describes the experimental design underlying the `biofilm` data set. 
The primary function `biofilm_exp` is to provide info for labelling 
and grouping data in some of the plotting functions from 
the **Bioconductor** package `r Biocpkg("DEP")`, which have been 
modified for use in this package. `biofilm_exp` supplies sample 
information (biological replicate, strain) for each 
`LFQ.intensity` column in the `biofilm` data.frame.

It has the following structure. Notice that each row in the `label` 
column of `biofilm_exp` is exactly the same as the names of the 
`LFQ.intensity` columns of `biofilm`.

```{r bexpTable}
knitr::kable(biofilm_exp, 
             caption = "Experimental design for this vignette.")
```

## Data preparation

First, the `biofilm` proteinGroups data.frame is filtered to remove reverse 
proteins, contaminant proteins, and proteins identified by less than 2 unique 
peptides.

```{r bInit, echo=TRUE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
biofilm_lfq <- biofilm %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., biofilm_exp)
```

Then the data.frame is converted into a compact format using the `convert_lfq` 
function which performs the following:

1. Ensures the names of the `LFQ.intensity` columns in `biofilm` exactly match 
   those in the `label` column of the experimental design, `biofilm_exp`.
   
2. Returns a matrix containing only: the UniProt accession(s) and LFQ 
   intensities of each protein across the 10 samples. 
   
3. Log<sub>2</sub> transforms the LFQ intensities.

--------------------------------------------------------------------------------

The resulting matrix `biofilm_lfq` still has `r nrow(biofilm_lfq)` rows but 
only `r ncol(biofilm_lfq)` columns, one for each LC-MS/MS sample. The total
number of proteins quantified (i.e. have a non-`NA` LFQ intensity) in each
sample can be explored using:
```{r, echo=TRUE, eval=FALSE}
# explore quantification across all 12 samples
plot_frequency2(biofilm_lfq)

# explore protein quantification in individual samples
plot_numbers2(biofilm_lfq, biofilm_exp)
```
The proteins in this data set 
are not quantified in every biological replicate of every strain. 
If fact in Figure \@ref(fig:bInit2)A shows that most of the proteins are 
only quantified in a single sample. Figure \@ref(fig:bInit2)B shows the 
total number of proteins quantified in each sample.

```{r bInit2, fig.cap=bInit2_cap, fig.wide=TRUE}
freq1 <- plot_frequency2(biofilm_lfq) + 
  scale_y_continuous(limits = c(0,450), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb1 <- plot_numbers2(biofilm_lfq, biofilm_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 1550), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:5, 2))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq1, numb1,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

bInit2_cap <- "Protein quantification distributions. (A) Cumulative 
               number of proteins quantified in 1-10 samples. (B) Total number 
               of proteins quantified in each biological replicate sample."
```

The percentage of non-valid (`NA`) values and other useful statistics for 
each sample is shown using:
```{r, echo=TRUE, eval=FALSE}
# generate summary table from LFQ data
sum_table(biofilm_lfq)
```
Table \@ref(tab:bInit3) shows that biological replicate 3 of both EV and WCL 
has the highest percentage of missing values compared to the other replicates. 

```{r bInit3}
knitr::kable(sum_table(biofilm_lfq), 
             caption = "Descriptive statistics for each LC-MS/MS sample.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

## Protein filtering (replicate quantification)

Prior to normalisation and imputation, proteins with too many missing values 
across the 10 samples are removed. Only those with at least 4/5 valid values 
in 1 of the 2 conditions are retained.

This filtration is performed using `filter_na2`.

```{r, bFilt}
# filter for proteins identified in min 4/5 reps of EV or WCL
biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)
```

The initial `r nrow(biofilm_lfq)` proteins has been reduced to 
`r nrow(biofilm_filt)`. Now the majority of proteins are quantified in all 10 
samples. The overall pattern of proteins in each sample remains similar 
though.

```{r bFilt2, fig.cap=bFilt2_cap, fig.wide=TRUE}
freq2 <- plot_frequency2(biofilm_filt) + 
  scale_y_continuous(limits = c(0,400), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb2 <- plot_numbers2(biofilm_filt, biofilm_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 1000), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:5, 2))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq2, numb2,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

bFilt2_cap <- "Protein quantification distributions after filtration. 
               (A) Cumulative number of proteins quantified in 1-10 samples. 
               (B) Total number of proteins quantified in each biological 
               replicate sample."
```

A multidimensional scaling plot can be drawn via:
```{r, echo=TRUE, eval=FALSE}
# need labels for the MDS plot
mds_labels <- c(rep("EV", 5), 
                rep("WCL", 5))

# generate MDS plot
plot_mds(biofilm_filt, mat_labels = mds_labels, 
         shape_size = 4)
```
It shows that the WCL samples generally cluster closer together than 
the EV samples do to each other, indicating they have a smaller 
log<sub>2</sub> fold change between them.


```{r bFilt3, fig.cap=bFilt3_cap, fig.small=TRUE}
mds1_labels <- c(rep("EV", 5), 
                 rep("WCL", 5))

plot_mds(biofilm_filt, mat_labels = mds1_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-1, 1), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-2.5, 2), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

bFilt3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
               biological replicate sample with the first 2 dimensions 
               plotted. Pairwise distance between samples approximately 
               indicates the log2 fold change between samples."
```

## LFQ intensity normalisation

Next, the LFQ intensity data is normalised using `r Biocpkg("limma")`.

```{r bNorm, echo=TRUE}
# normalise LFQ intensities
biofilm_norm <- limma::normalizeCyclicLoess(biofilm_filt)
```

The effect of the normalisation on the distribution of LFQ intensities for 
each sample is visualised using: 
```{r, echo=TRUE, eval=FALSE}
# explore effect of normalisation on intensity distributions
plot_normalization2(biofilm_exp, biofilm_filt, biofilm_norm)
```

```{r, bNorm2, fi.cap=bNorm2_cap, fig.height=7}
plot_normalization2(biofilm_exp, 
                    facet_labels = c(biofilm_filt = "Before normalisation", 
                                     biofilm_norm = "After normalisation"), 
                    biofilm_filt, biofilm_norm) + 
  scale_x_discrete(labels = c(rep(1:5, 2))) + 
  xlab("Biological replicate") + 
  theme(plot.margin = margin(t = 0, l = 1.5, r = 1.5, b = 0, unit = "inches"))
  

bNorm2_cap <- "Distribution of protein LFQ intensities for each sample. Shown
               before and after normalisation."
```

The MDS plot still shows that the WCL cluster closer together than the EV 
samples do to each other. Additionally, the first dimension (which is the 
leading factor causing the LFQ intensities differences between samples) 
separates the samples according to the primary condition of interest; EV 
versus WCL.

```{r bNorm3, fig.cap=bNorm3_cap, fig.small=TRUE}
mds2_labels <- c(rep("EV", 5), 
                rep("WCL", 5))

plot_mds(biofilm_norm, mat_labels = mds2_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-1, 1), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-1.5, 1.5), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

bNorm3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
               biological replicate sample after normalisation, with the 
               first 2 dimensions plotted. Pairwise distance between samples 
               approximately 
               indicates the log2 fold change between samples."
```



```{r biofilmVenn}
# filter for proteins identified in min 1/5 reps of EV
b_ev <- filter_na(biofilm_norm, op = "<=", 
                  pat = "EV", val = 4)

# filter for proteins identified in min 1/5 reps of WCL
b_wcl <- filter_na(biofilm_norm, op = "<=", 
                   pat = "W", val = 4)

b4 <- plot_venn(list("EV" = b_ev, "WCL" = b_wcl), 
                 use_uniprot = TRUE, type = "plot")

b4 <- as_ggplot(b4) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(b4)

```

Text

```{r biofilmTop10}
# get top 10 most abundant protein exclusive to biofilm EVs
# in descending order of abundance
biofilm_top10 <- b_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "W", val = 5) %>% 
  select(-contains("W")) %>% 
  mutate(mean = rowMeans(select(., contains("EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  mutate(protein_name = match_id(id, uniprot, "UP_accession", "CGD_gene_name"), 
         GO_CC = match_id(id, uniprot, "UP_accession", "GO_CC"))

knitr::kable(biofilm_top10, 
             caption = "This is a table caption", 
             digits = 1)
  

```

Text.

```{r biofilmSum}
# explore percentage missing values in each sample
knitr::kable(summarise_lfq(biofilm_norm), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

```

TEXT.

TEXT.

```{r biofilmSum2, cache=TRUE}
# should not impute with so many missing values
# filter for proteins with 4-5 NA values in EV or WCL
biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

# filter for proteins with min 3 valid values in EV and WCL
biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

knitr::kable(summarise_lfq(biofilm_both), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

b5a <- grid::grid.grabExpr(plot_missval2(biofilm_both))

b5b <- grid::grid.grabExpr(plot_detect2(biofilm_both))

ggarrange(b5a, b5b, 
          labels = c("A", "B"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, colour = "black"))

```

TEXT. 

```{r biofilmImpute}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
biofilm_imp <- impute_QRILC(biofilm_both)

plot_imputation2(biofilm_exp, biofilm_both, biofilm_imp)

```

TEXT.

```{r biofilmDE}
# recombine imputed proteins and non-imputed proteins in matrix
biofilm_de <- rbind(biofilm_excl, biofilm_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
b_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 5)))
b_design <- stats::model.matrix(~ 0 + T, data = b_samp)
colnames(b_design) <- c("EV", "WCL")

# make all pair-wise comparisons between EV and WCL
b_cm <- makeContrasts("EV_vs_WCL" = EV - WCL, levels = b_design)
b_fit <- lmFit(biofilm_de, design = b_design)
b_fit_cm <- contrasts.fit(b_fit, b_cm)
b_efit <- eBayes(b_fit_cm)

# extract DE results and create results table
biofilm_tt <- topTable(b_efit, sort.by = "none", number = Inf) %>% 
  as.matrix()

biofilm_res <- combine_result(mat = biofilm_de, toptab = biofilm_tt) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "UP_accession") %>% 
  mutate(group = case_when(significant == 0 ~ "not sig",
                           significant == 1 & logFC > 0 ~ "ev up",
                           significant == 1 & logFC < 0 ~ "wcl up",
                           is.na(significant) == TRUE & UP_accession %in% rownames(b_ev) ~ "ev ex",
                           is.na(significant) == TRUE & UP_accession %in% rownames(b_wcl) ~ "wcl ex"),
         in_ev = ifelse(UP_accession %in% rownames(b_ev), TRUE, FALSE),
         in_wcl = ifelse(UP_accession %in% rownames(b_wcl), TRUE, FALSE),
         CGD_gene_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "CGD_gene_name"),
         Protein_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "Protein_name"), 
         significant = as.logical(significant)) %>%
  select(UP_accession, CGD_gene_name, Protein_name, everything())

biofilm_res_short <- biofilm_res %>% 
  select(CGD_gene_name, Protein_name, logFC, AveExpr, adj.P.Val, significant, group) %>% 
  mutate_at(.vars = vars(logFC, AveExpr), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))

DT::datatable(biofilm_res_short, 
              caption = "This is a table caption. Note that adjusted p values have been shortened
              to three significant figures for ease of display.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val", 
                           "sig" = "significant"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = DT::JS(
                                         "function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 40 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 40) + '...</span>' : data;",
                                         "}")), 
                                  list(targets = 0, 
                                       render = DT::JS("function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 12 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 12) + '...</span>' : data;",
                                         "}"))
                                  )
                )
              )


```


# Comparison to previous data

TEXT

```{r biofilmComp}
z_list_b <- zarnowski %>% 
  filter(Biofilm_NTS > 0) %>% 
  mutate(gn = match_id(UP_accession, uniprot, "UP_accession", "CGD_gene_name")) %>% 
  pull(gn)

b_ev_list <- match_id(rownames(b_ev), uniprot, "UP_accession", "CGD_gene_name", concat = FALSE)

c1 <- plot_venn(list("mylist" = b_ev_list, "Zarn" = z_list_b), 
                 use_uniprot = FALSE, type = "plot")

c1 <- as_ggplot(c1) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(c1)

```

TEXT















