---
title: "Marker analysis"
author: "Charlotte Dawson"
date: "2018-01-20"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    df_print: kable
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(collapse = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      echo = FALSE,
                      comment = "#>")
# use fig.path="../vignettes/figures" to save generated figures
library(limma)
library(dplyr)
library(ggplot2)
library(candidaev)
library(ggpubr)
library(UpSetR)

set.seed(1)
```

# Introduction


# Yeast DAY286 

## Analysis

Text.

```{r yeastData}
yeast <- yeast %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

yeast_lfq <- convert_lfq(yeast, yeast_exp)

# drop EV_1 and WCL_2
yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_2")]

# filter for proteins identified in min 2/3 reps of EV or WCL
yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- normalizeCyclicLoess(yeast_filt2)

# filter for proteins identified in min 1/3 reps of EV
y_ev <- filter_na(yeast_norm2, op = "<=", 
                  pat = "EV", val = 2)

# filter for proteins identified in min 1/3 reps of WCL
y_wcl <- filter_na(yeast_norm2, op = "<=", 
                   pat = "W", val = 2)

# should not impute with so many missing values
yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both)

# recombine imputed proteins and non-imputed proteins in matrix
yeast_de <- rbind(yeast_excl, yeast_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
y_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))
y_design <- stats::model.matrix(~ 0 + T, data = y_samp)
colnames(y_design) <- c("EV", "WCL")

# make all pair-wise comparisons between EV and WCL
y_cm <- makeContrasts("EV_vs_WCL" = EV - WCL, levels = y_design)
y_fit <- lmFit(yeast_de, design = y_design)
y_fit_cm <- contrasts.fit(y_fit, y_cm)
y_efit <- eBayes(y_fit_cm)

# extract DE results and create results table
yeast_tt <- topTable(y_efit, sort.by = "none", number = Inf) %>% 
  as.matrix()

yeast_res <- combine_result(mat = yeast_de, toptab = yeast_tt) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "UP_accession") %>% 
  mutate(group = case_when(significant == 0 ~ "not sig",
                           significant == 1 & logFC > 0 ~ "ev up",
                           significant == 1 & logFC < 0 ~ "wcl up",
                           is.na(significant) == TRUE & UP_accession %in% rownames(y_ev) ~ "ev ex",
                           is.na(significant) == TRUE & UP_accession %in% rownames(y_wcl) ~ "wcl ex"),
         in_ev = ifelse(UP_accession %in% rownames(y_ev), TRUE, FALSE),
         in_wcl = ifelse(UP_accession %in% rownames(y_wcl), TRUE, FALSE),
         CGD_gene_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "CGD_gene_name"),
         Protein_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "Protein_name"), 
         significant = as.logical(significant)) %>%
  select(UP_accession, CGD_gene_name, Protein_name, everything())

```

Text.

# Biofilm DAY286

## Analysis

Text.

```{r biofilmData}
biofilm <- biofilm %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

biofilm_lfq <- convert_lfq(biofilm, biofilm_exp)

# filter for proteins identified in min 4/5 reps of EV or WCL
biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- normalizeCyclicLoess(biofilm_filt)

# filter for proteins identified in min 1/5 reps of EV
b_ev <- filter_na(biofilm_norm, op = "<=", 
                  pat = "EV", val = 4)

# filter for proteins identified in min 1/5 reps of WCL
b_wcl <- filter_na(biofilm_norm, op = "<=", 
                   pat = "W", val = 4)

# should not impute with so many missing values
# filter for proteins with 4-5 NA values in EV or WCL
biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

# filter for proteins with min 3 valid values in EV and WCL
biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
biofilm_imp <- impute_QRILC(biofilm_both)

# recombine imputed proteins and non-imputed proteins in matrix
biofilm_de <- rbind(biofilm_excl, biofilm_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
b_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 5)))
b_design <- stats::model.matrix(~ 0 + T, data = b_samp)
colnames(b_design) <- c("EV", "WCL")

# make all pair-wise comparisons between EV and WCL
b_cm <- makeContrasts("EV_vs_WCL" = EV - WCL, levels = b_design)
b_fit <- lmFit(biofilm_de, design = b_design)
b_fit_cm <- contrasts.fit(b_fit, b_cm)
b_efit <- eBayes(b_fit_cm)

# extract DE results and create results table
biofilm_tt <- topTable(b_efit, sort.by = "none", number = Inf) %>% 
  as.matrix()

biofilm_res <- combine_result(mat = biofilm_de, toptab = biofilm_tt) %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "UP_accession") %>% 
  mutate(group = case_when(significant == 0 ~ "not sig",
                           significant == 1 & logFC > 0 ~ "ev up",
                           significant == 1 & logFC < 0 ~ "wcl up",
                           is.na(significant) == TRUE & UP_accession %in% rownames(b_ev) ~ "ev ex",
                           is.na(significant) == TRUE & UP_accession %in% rownames(b_wcl) ~ "wcl ex"),
         in_ev = ifelse(UP_accession %in% rownames(b_ev), TRUE, FALSE),
         in_wcl = ifelse(UP_accession %in% rownames(b_wcl), TRUE, FALSE),
         CGD_gene_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "CGD_gene_name"),
         Protein_name = match_id(.[["UP_accession"]], uniprot, "UP_accession", "Protein_name"), 
         significant = as.logical(significant)) %>%
  select(UP_accession, CGD_gene_name, Protein_name, everything())


```

Text.

# Different strains test
## Introduction

Aim is to determine whether identified potential biomarkers work in other 
*C. albicans* strains.

## Experimental design info
Strain used:

<div id="left">
- ATCC10231
- zzzzzz
</div>

<div id="right">
- ATCC90028
- zzzzzzz
</div>

## Analysis
    
### Prepare data

The untouched proteinGroups.txt file has `r nrow(atcc)` rows and `r ncol(atcc)`  columns.

Each of the `r nrow(atcc)` rows corresponds to a single protein group. 

```{r atccData}
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", Potential.contaminant != "+", Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)

atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

atcc_norm <- normalizeCyclicLoess(atcc_filt)

# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A10231_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, op = "<=", 
                     pat = "A10231_W", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_W", val = 2)

# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
atcc_excl <- filter_na4(atcc_norm, logic = "or", op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)

# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, logic = "and", op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

atcc_de <- rbind(atcc_excl, atcc_imp)

colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)

# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")

atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W", "A1_EV - A9_EV", "A1_W - A9_W")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "overall")

# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "individual")

a1_res <- atcc_ind[[1]]

a9_res <- atcc_ind[[2]]

aev_res <- atcc_ind[[3]]

aw_res <- atcc_ind[[4]]



```



# EV marker protein selection

TEXT.

```{r markerComparison}

marker_comp <- list("yev up" = yeast_res %>% 
                      filter(group == "ev up") %>% 
                      pull(CGD_gene_name), 
                    "yev ex" = yeast_res %>% 
                      filter(group == "ev ex") %>% 
                      pull(CGD_gene_name), 
                    "bev up" = biofilm_res %>% 
                      filter(group == "ev up") %>% 
                      pull(CGD_gene_name), 
                    "bev ex" = biofilm_res %>% 
                      filter(group == "ev ex") %>% 
                      pull(CGD_gene_name))

upset(fromList(marker_comp), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree")
marker_comp_tab <- plot_venn(vlist = marker_comp, use_uniprot = FALSE, type = "list")

knitr::kable(marker_comp_tab, 
             caption = "A table caption")


marker_comp2 <- list("a1_ev up" = a1_res %>% 
                      filter(group == "A1_EV up") %>% 
                      pull(CGD_gene_name), 
                    "a1_ev ex" = a1_res %>% 
                      filter(group == "A1_EV ex") %>% 
                      pull(CGD_gene_name), 
                    "a9_ev up" = a9_res %>% 
                      filter(group == "A9_EV up") %>% 
                      pull(CGD_gene_name), 
                    "a9_ev ex" = a9_res %>% 
                      filter(group == "A9_EV ex") %>% 
                      pull(CGD_gene_name))

upset(fromList(marker_comp2), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree")
marker_comp_tab2 <- plot_venn(vlist = marker_comp2, use_uniprot = FALSE, type = "list")

knitr::kable(marker_comp_tab2, 
             caption = "A table caption")


```

TEXT.

```{r markerExtract}
# marker_candidates <- marker_comp_tab %>% 
#   filter(..count.. > 0 & ..count.. < 40) %>% 
#   pull(..values..) %>% 
#   set_names(c("both ex", "yev up bev ex", "yev ex bev up", "both up"))

marker_candidates <- marker_comp_tab %>% 
  filter(..count.. > 0 & apply(.[, 1:4], 1, sum) > 1) %>% 
  pull(..values..) %>% 
  unlist()

marker_candidates2 <- marker_comp_tab2 %>% 
  filter(..count.. > 0 & apply(.[, 1:4], 1, sum) > 1) %>% 
  pull(..values..) %>% 
  unlist()

test_can <- intersect(marker_candidates, marker_candidates2) %>% 
  stringr::str_extract_all(., "[^;]+") %>% 
  unlist()

test <- uniprot %>% 
  filter(CGD_gene_name %in% test_can)

DT::datatable(test, 
              caption = "This is a table caption.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(targets = c(7:10, 13:21), 
                                       render = DT::JS(
                                         "function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 40 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 40) + '...</span>' : data;",
                                         "}"))
                                  )
                )
              )

```


