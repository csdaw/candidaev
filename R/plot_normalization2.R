#' Visualise effect of normalisation on protein intensity distribution
#'
#' @description \code{plot_normalization2} generates boxplots
#' of all conditions for input objects, e.g. before and after normalization.
#'
#' This function has been taken directly from the \code{plot_normalization}
#' function in the \href{http://doi.org/10.18129/B9.bioc.DEP}{DEP} package and
#' then modified for use in this package.
#'
#' \href{http://doi.org/10.18129/B9.bioc.DEP}{DEP} is distributed with the
#' Artistic-2.0 license
#' which requires any source code modifications to be clearly stated.
#'
#' \code{plot_normalization2} includes the following modifications
#' of \code{plot_normalization}:
#'
#' \itemize{
#' \item Dependance on a "SummarizedExperiment" object as input has been
#' removed. Instead the input has been changed to a numeric matrix.
#' \item Use of \code{theme_DEP1()} has been replaced with \code{theme_bw()}
#' }
#'
#' @param exd data.frame: contains information for plot labels. See the
#' examples section of \code{\link{assert_exd}} or \code{\link{atcc_exp}} for
#' examples of appropriately structured experimental designs.
#'
#' @param mat numeric matrix: LFQ intensity data before normalisation
#'
#' @param ... numeric matrix/matrices: LFQ intensity data after normalisation.
#' Multiple matrices can be input for plotting.
#'
#' @return Returns box plots of all input matrices, e.g. before and
#' after normalisation (generated by \code{\link[ggplot2]{ggplot}}).
#'
#' @examples
#' # load dplyr
#' library(dplyr)
#'
#' # load a proteinGroups data.frame supplied with this package
#' my_proteinGroups <- atcc
#'
#' # load its corresponding experimental design
#' my_expDesign <- atcc_exp
#'
#' # filter for proteins identified with minimum 3 unique peptides
#' # and convert to numeric matrix
#' my_lfq <- my_proteinGroups %>%
#'   filter(Unique.peptides >= 3) %>%
#'   convert_lfq(., my_expDesign)
#'
#' # filter for proteins quantified in min 2/3 reps of
#' # at least 1 sample group
#' my_filt <- my_lfq %>%
#'   filter_na4(., logic = "or", op = "<=",
#'              pat1 = "A10231_EV", val1 = 1,
#'              pat2 = "A10231_W", val2 = 1,
#'              pat3 = "A90028_EV", val3 = 1,
#'              pat4 = "A90028_W", val4 = 1)
#'
#' # normalise LFQ intensities using limma
#' my_norm <- limma::normalizeCyclicLoess(my_filt)
#'
#' # normalise LFQ intensities
#' # using some other function from limma
#' my_norm2 <- limma::normalizeQuantiles(my_filt)
#'
#' # box plots before and after normalisations
#' plot_normalization2(exd = atcc_exp,
#'                     my_filt,
#'                     my_norm,
#'                     my_norm2)
#'
#' @export
plot_normalization2 <- function(exd, mat, ...) {
  # Get arguments from call
  call <- match.call()
  arglist <- lapply(call[-1], function(x) x)
  var.names <- vapply(arglist, deparse, character(1))
  arglist <- lapply(arglist, eval.parent, n = 2)
  names(arglist) <- var.names
  arglist <- arglist[-1]

  # Show error if inputs are not the required classes
  assertthat::assert_that(is.data.frame(exd),
                          assert_exd(exd))
  lapply(arglist, function(x) {
    assertthat::assert_that(is.matrix(x))
  })

  # Internal function to get a long data.frame of the assay data
  # annotated with sample info
  gather_join2 <- function(mat) {
    as.data.frame(mat) %>%
      tidyr::gather(ID, val) %>%
      left_join(., as.data.frame(exd), by = "ID")
  }

  df <- purrr::map_df(arglist, gather_join2, .id = "var") %>%
    mutate(var = factor(var, levels = names(arglist)))

  # Boxplots for conditions with facet_wrap
  # for the original and normalized values
  ggplot(df, aes(x = ID, y = val, fill = condition)) +
    geom_boxplot(notch = TRUE, na.rm = TRUE) +
    coord_flip() +
    facet_wrap(~var, ncol = 1) +
    labs(x = "", y = expression(log[2]~"LFQ intensity")) +
    theme_bw(base_size = 12)
}
