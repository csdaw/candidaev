---
title: "ATCC analysis"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
- name: Harinda Rajapaksha
  affiliation: La Trobe Comprehensive Proteomics Platform, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
- name: Pierre Faou
  affiliation: La Trobe Comprehensive Proteomics Platform, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute for Molecular Science, 
               La Trobe University, Melbourne, 3086, 
               Victoria, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  Analysis of LC-MS/MS data obtained for _Candida albicans_ (strains = 
  ATCC90028, ATCC10231) extracellular vesicles and yeast whole cell lysate.
vignette: > 
  %\VignetteIndexEntry{ATCC analysis}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r knitrOpts, include=FALSE}
# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = FALSE,
                      warning = TRUE,
                      message = TRUE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")

# check for installation of packages required to knit this vignette
req_pkgs <- c("BiocStyle", "ggpubr", "stringi", "DT")

check_pkgs <- function(x) {
  if(!requireNamespace(x, quietly = TRUE)) {
    stop(paste0("The package ",
                paste0(x),
                " is required to knit this document. 
                Please install it."))
  }
}

lapply(req_pkgs, check_pkgs)
```

# Preface

## Introduction

This vignette outlines the method used to analyse the label-free quantitative 
LC-MS/MS data obtained for _C. albicans_ (strains ATCC10231 and ATCC90028) 
extracellular vesicles (EVs) and whole cell lysates (WCL) by Dawson et 
al. (2019). The tools provided in this package, `r Githubpkg("csdaw/candidaev")`
, allows the step-by-step reproduction of the results presented in the paper. 
The manuscript in its submitted form and the `.Rmarkdown` file used to 
generate it can found 
[here](https://github.com/csdaw/candidaev/tree/master/manuscript).

The analysis workflow used in this vignette is derived from the excellent 
**Bioconductor** package `r Biocpkg("DEP")`[^1]. Furthermore, some of the 
plotting functions available in `r Biocpkg("DEP")` have been modified for use 
in this package, `r Githubpkg("csdaw/candidaev")`. 

[^1]: Zhang, X., Smits, A. H., van Tilburg, G. B. A., Ovaa, H., Huber, W., & 
Vermeulen, M. (2018). Proteome-wide identification of ubiquitin interactions 
using UbIA-MS. _Nature Protocols, 13_(3), 530-550. 
[doi:10.1038/nprot.2017.147](https://doi.org/10.1038/nprot.2017.147)

## Experimental design

Extracellular vesicles (EVs) were isolated using differential 
ultracentrifugation from _C. albicans_ liquid cultures 
from two clinical isolate strains; ATCC10231 (n = 3) and ATCC90028 (n = 3). 
Additionally, cells from these liquid cultures were separated and lysed to 
generate whole cell lysates (WCL). Each EV biological replicate was paired 
with a WCL replicate as they were derived from the same liquid culture.

Samples analysed in this vignette:

* ATCC10231 EV1
* ATCC10231 EV2
* ATCC10231 EV3
* ATCC10231 WCL1 (W1)
* ATCC10231 WCL2 (W2)
* ATCC10231 WCL3 (W3)

and

* ATCC90028 EV1
* ATCC90028 EV2
* ATCC90028 EV3
* ATCC90028 WCL1 (W1)
* ATCC90028 WCL2 (W2)
* ATCC90028 WCL3 (W3)

These samples were electrophoresed and the SDS-PAGE gel slices were 
reduced, alkylated, and digested with trypsin. The resulting peptides were 
extracted with acetonitrile, analysed by nano-LC-ESI-MS/MS, identified using 
MaxQuant, and quantified via the MaxLFQ algorithm in MaxQuant. 
The `proteinGroups.txt` file output was used for subsequent analyses.

## Data availability

The raw data was searched against the _C. albicans_ (SC5314) UniProt 
reference proteome (UP000000559) using MaxQuant version 1.6.0.16.  The 
`proteinGroups.txt` file analysed in this vignette 
can be easily accessed 
[here](https://github.com/csdaw/candidaev/tree/master/data-raw/lcms). 
It is also installed along with the 
`r Githubpkg("csdaw/candidaev")` package and can be loaded in R with 

```
data(atcc)
```

The LC-MS/MS raw data, peak data, and results files have been 
deposited in the ProteomeXchange Consortium database via the PRIDE partner 
repository with the data set identifier PXD014388. 

# Data analysis
    
## Setup

The packages required for the analyses are loaded and a specific 
seed is set for the steps requiring random number generation (imputation 
and clustering).

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
# load packages
library(candidaev)
library(dplyr)
library(ggplot2)

# set seed for imputation, kmeans, MDS plot
set.seed(1)
```

To reproduce the results exactly as they are in Dawson et al. (2019), the 
following code block is run to perform a specific number of draws from 
a random distribution before performing the analysis of the `atcc` data. 
Otherwise, the results will be extremely similar but not identical to Dawson 
et al. (2019).

```{r randomDraws, echo=TRUE}
# for results to be reproducible in seperate documents
# need to use set.seed AND need to perform same number of 
# 'random' draws in the same order as manuscript.Rmd

# DAY286 yeast
yeast_lfq <- yeast %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., yeast_exp)

yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_0", "WCL_0")]

yeast_filt2 <- filter_na2(yeast_lfq2, 
                          logic = "or", 
                          op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- limma::normalizeCyclicLoess(yeast_filt2)

yeast_excl <- filter_na2(yeast_norm2, 
                         logic = "or", 
                         op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, 
                         logic = "and", 
                         op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both) # first set of random draws

# DAY286 biofilm
biofilm_lfq <- biofilm %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., biofilm_exp)

biofilm_filt <- filter_na2(biofilm_lfq, 
                           logic = "or", 
                           op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- limma::normalizeCyclicLoess(biofilm_filt)

biofilm_excl <- filter_na2(biofilm_norm, 
                           logic = "or", 
                           op = ">=", 
                           pat1 = "EV", val1 = 4, 
                           pat2 = "W", val2 = 4)

biofilm_both <- filter_na2(biofilm_norm, 
                           logic = "and", 
                           op = "<=", 
                           pat1 = "EV", val1 = 3, 
                           pat2 = "W", val2 = 3)

biofilm_imp <- impute_QRILC(biofilm_both) # second set of random draws
```

## Exploring the `atcc` data set

As above, the _C. albicans_ ATCC LC-MS/MS data set is provided as a 
data.frame called `atcc` in this package. 
It has `r nrow(atcc)` rows each of which corresponds to a single protein 
group[^2], and `r ncol(atcc)` columns. 
A key describing most of these columns can be found in the 
[MaxQuant documentation](http://www.coxdocs.org/doku.php?id=maxquant:table:proteingrouptable). 
The `LFQ.intensity` columns hold the protein quantification data that is 
used for the following analyses.

[^2]: Each protein group comprises the group of proteins that could be 
reconstructed from a set of peptides by MaxQuant. In most cases this will be 
a single protein but sometimes there will be two or more proteins that 
could not be distinguished by the set of peptides.

```{r atccColumns, echo=TRUE}
colnames(atcc)
```

`atcc_exp` is another data.frame provided in this package. It 
describes the experimental design underlying the `atcc` data set. 
The primary function `atcc_exp` is to provide info for labelling 
and grouping data in some of the plotting functions from 
the **Bioconductor** package `r Biocpkg("DEP")`, which have been 
modified for use in this package. `atcc_exp` supplies sample 
information (biological replicate, strain) for each 
`LFQ.intensity` column in the `atcc` data.frame.

It has the following structure. Notice that each row in the `label` 
column of `atcc_exp` is exactly the same as the names of the 
`LFQ.intensity` columns of `atcc`.

```{r atccexpTable}
knitr::kable(atcc_exp, 
             caption = "Experimental design for this vignette.")
```

## Data preparation

First, the `atcc` proteinGroups data.frame is filtered to remove reverse 
proteins, contaminant proteins, and proteins identified by less than 2 unique 
peptides.

```{r atccInit, echo=TRUE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)
```

Then the data.frame is converted into a compact format using the `convert_lfq` 
function which performs the following:

1. Ensures the names of the `LFQ.intensity` columns in `atcc` exactly match 
   those in the `label` column of the experimental design, `atcc_exp`.
   
2. Returns a matrix containing only: the UniProt accession(s) and LFQ 
   intensities of each protein across the 12 samples. 
   
3. Log<sub>2</sub> transforms the LFQ intensities.

--------------------------------------------------------------------------------

The resulting matrix `atcc_lfq` still has `r nrow(atcc_lfq)` rows but only 
`r ncol(atcc_lfq)` columns, one for each LC-MS/MS sample. The total number of 
proteins quantified (i.e. have a non-`NA` LFQ intensity) in each sample can 
be explored using:

```{r, echo=TRUE, eval=FALSE}
# explore quantification across all 12 samples
plot_frequency2(atcc_lfq)

# explore protein quantification in individual samples
plot_numbers2(atcc_lfq, atcc_exp)
```

The proteins in this data set 
are not quantified in every biological replicate of every strain. 
If fact in Figure \@ref(fig:atccInit2)A shows that most of the proteins are 
only quantified in a single sample. Figure \@ref(fig:atccInit2)B shows the 
total number of proteins quantified in each sample.

```{r atccInit2, fig.cap=atccInit2_cap, fig.wide=TRUE}
freq1 <- plot_frequency2(atcc_lfq) + 
  scale_y_continuous(limits = c(0,600), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb1 <- plot_numbers2(atcc_lfq, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 2250), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq1, numb1,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccInit2_cap <- "Protein quantification distributions. (A) Cumulative 
number of proteins quantified in 1-12 samples. (B) Total number of proteins 
quantified in each biological replicate sample."
```

The percentage of non-valid (`NA`) values and other useful statistics for 
each sample is shown using:

```{r, echo=TRUE, eval=FALSE}
# generate summary table from LFQ data
sum_table(atcc_lfq)
```

Table \@ref(tab:atccInit3) shows that the ATCC10231 samples have higher 
percentages of missing values than the ATCC90028 samples.

```{r atccInit3}
knitr::kable(sum_table(atcc_lfq), 
             caption = "Descriptive statistics for each LC-MS/MS sample.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

## Protein filtering (replicate quantification)

Prior to normalisation and imputation, proteins with too many missing values 
across the 12 samples are removed. Only those with at least 2/3 valid values 
in 1 of the 4 conditions are retained.

This filtration is performed using `filter_na4`.

```{r atccFilt, echo=TRUE}
# filter for proteins quantified in min 2/3 reps of: 
# A1 EV or A1 WCL or A9 EV or A9 WCL
atcc_filt <- filter_na4(atcc_lfq, 
                        logic = "or", 
                        op = "<=", 
                        pat1 = "A10231_EV", val1 = 1, 
                        pat2 = "A10231_W", val2 = 1, 
                        pat3 = "A90028_EV", val3 = 1, 
                        pat4 = "A90028_W", val4 = 1)
```

The initial `r nrow(atcc_lfq)` proteins has been reduced to 
`r nrow(atcc_filt)`. Now the majority of proteins are quantified in all 12 
samples. The overall pattern of proteins in each sample remains similar 
though.

```{r atccFilt2, fig.cap=atccFilt2_cap, fig.wide=TRUE}
freq2 <- plot_frequency2(atcc_filt) + 
  scale_y_continuous(limits = c(0,400), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb2 <- plot_numbers2(atcc_filt, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 1750), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq2, numb2,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccFilt2_cap <- "Protein quantification distributions after filtration. 
                  (A) Cumulative number of proteins quantified in 1-12 samples. 
                  (B) Total number of proteins quantified in each biological 
                  replicate sample."
```

A multidimensional scaling plot can be drawn via:

```{r, echo=TRUE, eval=FALSE}
# need labels for the MDS plot
mds_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

# generate MDS plot
plot_mds(atcc_filt, mat_labels = mds_labels, 
         shape_size = 4)
```

It shows that the WCL samples from both strains cluster closer together than 
the EV samples do to each other, indicating they have a smaller 
log<sub>2</sub> fold change between them.

```{r atccFilt3, fig.cap=atccFilt3_cap, fig.small=TRUE}
mds1_labels <- c(rep("EV", 3), 
                 rep("WCL", 3), 
                 rep("EV", 3), 
                 rep("WCL", 3))

plot_mds(atcc_filt, mat_labels = mds1_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-1.5, 0.75), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-4, 2), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccFilt3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
                  biological replicate sample with the first 2 dimensions 
                  plotted. Pairwise distance between samples approximately 
                  indicates the log2 fold change between samples."
```

## LFQ intensity normalisation

Next, the LFQ intensity data is normalised using `r Biocpkg("limma")`.

```{r atccNorm, echo=TRUE}
# normalise LFQ intensities
atcc_norm <- limma::normalizeCyclicLoess(atcc_filt)
```

The effect of the normalisation on the distribution of LFQ intensities for 
each sample is visualised using: 

```{r, echo=TRUE, eval=FALSE}
# explore effect of normalisation on intensity distributions
plot_normalization2(atcc_exp,
                    facet_labels = c(atcc_filt = "Before normalisation", 
                                     atcc_norm = "After normalisation"), 
                    atcc_filt, 
                    atcc_norm)
```

```{r atccNorm2, fig.cap=atccNorm2_cap, fig.height=7}
plot_normalization2(atcc_exp, 
                    facet_labels = c(atcc_filt = "Before normalisation", 
                                     atcc_norm = "After normalisation"), 
                    atcc_filt, atcc_norm) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  xlab("Biological replicate") + 
  theme(plot.margin = margin(t = 0, l = 1.5, r = 1.5, b = 0, unit = "inches"))
  

atccNorm2_cap <- "Distribution of protein LFQ intensities for each sample. Shown
                  before and after normalisation."
```

The MDS plot now shows that the first dimension (which is the leading factor 
causing the LFQ intensities differences between samples) separates the 
samples according to the primary condition of interest; EV versus WCL. Then 
the second dimension separates the samples according to the strain.

```{r atccNorm3, fig.cap=atccNorm3_cap, fig.small=TRUE}
mds2_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

plot_mds(atcc_norm, mat_labels = mds2_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-0.8, 0.8), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-1, 1), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccNorm3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
                  biological replicate sample after normalisation, with the 
                  first 2 dimensions plotted. Pairwise distance between samples 
                  approximately 
                  indicates the log2 fold change between samples."
```

## ATCC strain protein comparison

First, `atcc_norm` is split into two different matrices containing the 
ATCC90028 data (`a9_norm`), and the ATCC10231 data (`a1_norm`).

```{r atccSplit, echo=TRUE}
## ATCC90028 normalised LFQ data
# filter for proteins quantified in min 2/3 reps of EV or WCL
a9_norm <- filter_na2(atcc_norm, logic = "or", op = "<=",
                      pat1 = "A90028_EV", val1 = 1,
                      pat2 = "A90028_W", val2 = 1)
# drop ATCC10231 columns
a9_norm <- a9_norm[, -c(1:6)]

## ATCC10231 normalised LFQ data
# filter for proteins quantified in min 2/3 reps of EV or WCL
a1_norm <- filter_na2(atcc_norm, logic = "or", op = "<=", 
                      pat1 = "A10231_EV", val1 = 1, 
                      pat2 = "A10231_W", val2 = 1)

# drop ATCC90028 columns
a1_norm <- a1_norm[, -c(7:12)]
```

We can compare the distribution of proteins from `atcc_norm` in `a9_norm` and 
`a1_norm` using a Venn diagram.

```{r, echo=TRUE, eval=FALSE}
# define a comparison list for a Venn diagram
venn_comp <- list("ATCC90028" = rownames(a9_norm), 
                  "ATCC10231" = rownames(a1_norm))

# plot the Venn diagram
venn <- plot_venn(venn_comp, 
                  type = "df")

grid::grid.draw(venn)
```

```{r atccVenn, fig.cap=venn_cap, fig.small=TRUE}
# define a comparison list for a Venn diagram
venn_comp <- list("A90028" = rownames(a9_norm), 
                  "A10231" = rownames(a1_norm))

# define ggplot2 default colour palette function
gg_colour <- function(n) {
  hues <- seq(15, 375, length = n + 1)
  grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

# plot Venn diagram
venn <- plot_venn(venn_comp, 
                  use_uniprot = FALSE, 
                  type = "plot", 
                  fontfamily = "sans", 
                  cat.fontfamily = "sans", 
                  cex = 1.9, 
                  cat.cex = 1.2, 
                  fill = gg_colour(2), 
                  alpha = c(rep(0.4, 2)))

# draw Venn diagram
grid::grid.draw(venn)

venn_cap <- "Venn diagram of proteins quantified in both ATCC strains. 
             Proteins in this plot are quantified in at least 2/3 replicates 
             of EV or WCL from at least 1 strain."
```

Of the `r nrow(atcc_norm)` proteins in `atcc_norm`, 1153 (74.9%) proteins are
quantified by at least 2/3 replicates of EV or WCL from **both** strains. The
rest are quantified by at least 2/3 replicates of EV or WCL from **either** 
ATCC90028 or ATCC10231.

We can further compare these two strains by seeing how many proteins are 
unique to EVs or WCLs from both/either strain. Lists of proteins quantified 
in at least 1/3 biological replicates of each condition are generated using:

```{r atccVenn2Data, echo=TRUE}
## ATCC10231
# filter for proteins quantified in min 1/3 reps of ATCC10231 EV
# define 'EV proteins'
a1_ev <- filter_na(a1_norm, op = "<=", pat = "EV", val = 2)

# filter for proteins quantified in min 1/3 reps of ATCC10231 WCL
# define 'WCL proteins'
a1_wcl <- filter_na(a1_norm, op = "<=", pat = "W", val = 2)

# ATCC90028
# filter for proteins quantified in min 1/3 reps of ATCC90028 EV
# define 'EV proteins'
a9_ev <- filter_na(a9_norm, op = "<=", pat = "EV", val = 2)

# filter for proteins quantified in min 1/3 reps of ATCC90028 WCL
# define 'WCL proteins'
a9_wcl <- filter_na(a9_norm, op = "<=", pat = "W", val = 2)
```

These are then compared via a Venn diagram. 

```{r, echo=TRUE, eval=FALSE}
# define a comparison list for a Venn diagram
venn2_comp <- list("A10231_EV" = rownames(a1_ev), 
                   "A10231_WCL" = rownames(a1_wcl), 
                   "A90028_EV" = rownames(a9_ev), 
                   "A90028_WCL" = rownames(a9_wcl))

# plot the Venn diagram
venn2 <- plot_venn(venn2_comp, 
                   type = "plot")

grid::grid.draw(venn2)
```

```{r atccVenn2, fig.cap=venn2_cap}
# define comparison list for Venn diagram
venn2_comp <- list("A10231_EV" = rownames(a1_ev), 
                   "A10231_WCL" = rownames(a1_wcl), 
                   "A90028_EV" = rownames(a9_ev), 
                   "A90028_WCL" = rownames(a9_wcl))

# plot Venn diagram
venn2 <- plot_venn(venn2_comp, 
                   use_uniprot = FALSE, 
                   type = "plot", 
                   fontfamily = "sans", 
                   cat.fontfamily = "sans", 
                   cex = 1.9, 
                   cat.cex = 1.2, 
                   fill = gg_colour(4), 
                   alpha = c(rep(0.4, 4)))

# draw Venn diagram
grid::grid.draw(venn2)

venn2_cap <- "Venn diagram of proteins quantified in each condition. 
             Proteins in this plot are quantified in at least 2/3 replicates 
             of at least 1 condition for at least 1 strain."
```

Of the `r nrow(a9_norm)` ATCC90028 proteins and `r nrow(a1_norm)` ATCC10231
proteins, 631 (41.0%) are common to both EVs and WCLs from both strains. 
Furthermore, there are 94 proteins only detected in EVs from both strains, and 
160 proteins only detected in WCL.

## Top 10 most abundance EV exclusive proteins

The most abundant proteins that are only detected in ATCC10231 EVs and 
not in ATCC10231 WCL can be identified.

```{r a1Top10Data, echo=TRUE}
# get top 10 most abundant proteins exclusive to ATCC10231 EVs
# in descending order of abundance
a1_top10 <- a1_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A10231_W", val = 3) %>% 
  select(id, contains("A10231_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A10231_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)
```

```{r a1Top10}
knitr::kable(a1_top10, 
             caption = "Top 10 most abundant ATCC10231 EV proteins. They are 
                        not detected in ATCC10231 WCL.", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

This is repeated for ATCC90028. The proteins MSB2, PLB4.5, orf19.6119, and 
orf19.1054 are highly abundant and exclusive to EVs from both strains.

```{r a9Top10Data, echo=TRUE}
a9_top10 <- a9_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A90028_W", val = 3) %>% 
  select(id, contains("A90028_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A90028_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)
```

```{r a9Top10}
knitr::kable(a9_top10, 
             caption = "Top 10 most abundant ATCC90028 EV proteins. They are 
                        not detected in ATCC90028 WCL.", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

## Imputation of missing values

Missing values in the data will be imputed prior to the 
differential abundance analysis. Before imputation the percentage of missing 
values in each sample is explored again with `sum_table`.

```{r atccSum}
# explore percentage missing values in each ATCC10231 sample
knitr::kable(sum_table(a1_norm), 
             caption = "Descriptive statistics for each ATCC10231 LC-MS/MS 
                        sample. After normalisation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)

# explore percentage missing values in each ATCC90028 sample
knitr::kable(sum_table(a9_norm), 
             caption = "Descriptive statistics for each ATCC90028 LC-MS/MS 
                        sample. After normalisation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

The percentage of missing values ranges from 17.5%-55.8% which is 
quite high, typical of label-free quantitative proteomics data[^3]. The 
pattern of missing values across the data is visualised using:

[^3]: Lazar, C., Gatto, L., Ferro, M., Bruley, C., Burger, T. (2016). 
Accounting for the Multiple Natures of Missing Values in Label-Free 
Quantitative Proteomics Data Sets to Compare Imputation Strategies. 
_Journal of Proteome Research, 15_(4), 1116-1125. 
[doi:10.1021/acs.jproteome.5b00981](https://doi.org/10.1021/acs.jproteome.5b00981)

```{r, echo=TRUE, eval=FALSE}
# visualise missing values using a heatmap
plot_missval2(a1_norm)

plot_missval2(a9_norm)
```

```{r atccMissVal, fig.cap=missval_cap, fig.height=8}
# visualise missing values using a heatmap
plot_missval2(a1_norm)

plot_missval2(a9_norm)
missval_cap <- "Pattern of missing LFQ intensity values."
```

There are large chunks of data missing in either all of 
the WCL samples or all of the EV samples. To minimise the percentage of 
missing values in each sample, these proteins are removed prior to 
imputation and hence are not imputed.

```{r atccExcl, echo=TRUE}
# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
# these will not be imputed
a1_excl <- filter_na2(a1_norm, logic = "or", op = "==",
                      pat1 = "EV", val1 = 3,
                      pat2 = "W", val2 = 3)

a9_excl <- filter_na2(a9_norm, logic = "or", op = "==",
                      pat1 = "EV", val1 = 3,
                      pat2 = "W", val2 = 3)
```

Only proteins quantified in at least 1/3 replicates from all both EV and WCL  
are retained for imputation.

```{r atccBoth, echo=TRUE}
# filter for proteins with min 1 valid value in both EV and WCL
a1_both <- filter_na2(a1_norm, logic = "and", op = "<=",
                      pat1 = "EV", val1 = 2,
                      pat2 = "W", val2 = 2)

a9_both <- filter_na2(a9_norm, logic = "and", op = "<=",
                      pat1 = "EV", val1 = 2,
                      pat2 = "W", val2 = 2)
```

`r nrow(a1_excl)` proteins which are exclusive to either ATCC10231 EV or WCL 
are set aside in `a1_excl` and `r nrow(a1_both)` proteins are kept to have 
missing values imputed (`a1_both`). Similarly, `r nrow(a9_excl)` proteins 
are exclusive to ATCC90028 EVs or WCL (`a9_excl`) and `r nrow(a9_both)` 
are retained for 
imputation (`a9_both`). The percentage of missing values across each sample 
in `a1_both` and `a9_both` now ranges from 4.9% to 31.3%. 

```{r atccSum2}
# explore percentage missing values in each ATCC10231 common proteins
knitr::kable(sum_table(a1_both), 
             caption = "Descriptive statistics for each ATCC10231 LC-MS/MS 
                        sample. After normalisation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)

# explore percentage missing values in each ATCC90028 common proteins
knitr::kable(sum_table(a9_both), 
             caption = "Descriptive statistics for each ATCC90028 LC-MS/MS 
                        sample. After normalisation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

The patterns of missing values in `a1_both` and `a9_both` seem to be biased to 
certain samples, especially EV replicate 1 from both strains. Therefore, these 
proteins may be missing not at random (MNAR). 

```{r atccMissVal2, fig.cap=missval2_cap , fig.height=8}
# visualise missing values using a heatmap
plot_missval2(a1_both)

plot_missval2(a9_both)
missval2_cap <- "Pattern of missing LFQ intensity values."
```

The LFQ intensity distributions and cumulative fraction of proteins with and 
without missing values can be plotted with: 

```{r, echo=TRUE, eval=FALSE}
# detect intensity differences for proteins with missing values
plot_detect2(a1_both)

plot_detect2(a9_both)
```

```{r atccSum3, fig.cap=detect_cap, fig.wide=TRUE}
# detect intensity differences for proteins with missing values
plot_detect2(a1_both)

plot_detect2(a9_both)
detect_cap <- "LFQ intensities of proteins with and without missing values."
```

In both cases, these plots show that missing values are biased to proteins 
with lower average intensities, and are likely MNAR. 
Hence, a left-censored imputation method is used for imputation of 
missing values. 

```{r, echo=TRUE, eval=FALSE}
# impute missing values with QRILC method
a1_imp <- impute_QRILC(a1_both)

a9_imp <- impute_QRILC(a9_both)
```

The effect of imputation on the distribution of protein intensities is 
visualised with:

```{r, echo=TRUE, eval=FALSE}
plot_imputation2(exd = atcc_exp, 
                 facet_labels = c(a1_both = "ATCC10231 - Before imputation", 
                                  a1_imp = "ATCC10231 - After imputation", 
                                  a9_both = "ATCC90028 - Before imputation", 
                                  a9_imp = "ATCC90028 - After imputation")
                 a1_both, a1_imp, a9_both, a9_imp)
```

```{r atccImpute, fig.cap=imp_cap, fig.height=7}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
a1_imp <- impute_QRILC(a1_both)

a9_imp <- impute_QRILC(a9_both)

plot_imputation2(exd = atcc_exp, 
                 facet_labels = c(a1_both = "ATCC10231 - Before imputation", 
                                  a1_imp = "ATCC10231 - After imputation", 
                                  a9_both = "ATCC90028 - Before imputation", 
                                  a9_imp = "ATCC90028 - After imputation"), 
                 a1_both, a1_imp, a9_both, a9_imp)

imp_cap <- "LFQ intensity distribution before and after imputation."
```

## Differential abundance analysis with _limma_

Prior to differential abundance analysis, the imputed and non-imputed proteins 
are recombined in the same matrix.

```{r atccDE, echo=TRUE}
# combine matrices
a1_de <- rbind(a1_excl, a1_imp)
colnames(a1_de) <- gsub("A10231_", "", colnames(a1_de))
colnames(a1_de) <- gsub("W", "WCL", colnames(a1_de))

a9_de <- rbind(a9_excl, a9_imp)
colnames(a9_de) <- gsub("A90028_", "", colnames(a9_de))
colnames(a9_de) <- gsub("W", "WCL", colnames(a9_de))
```

A design matrix is constructed for this proteomics experiment. This is 
required for the linear model fit function (`lmFit`) from 
`r Biocpkg("limma")` which is called inside the `limma_eBayes` function in 
this package. See the _limma_ User Guide section 9.2
[here](https://bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf) 
for more information about constructing design matrices.

```{r atccDesign, echo=TRUE}
# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("EV", "WCL")
```

```{r atccDE2}
knitr::kable(atcc_design, 
             caption = "Design matrix for comparing EV and WCL samples.")
```

The comparisons between samples that one is interested in are defined in a 
character vector. These must be two column names from the design matrix 
separated by ` - `.

```{r atccDE3, echo=TRUE}
# specify comparisons of interest
atcc_contrasts <- c("EV - WCL")
```

Finally, the differential abundance analysis is performed using the 
`limma_eBayes` function from this package which calls `eBayes` from 
`r Biocpkg("limma")`. 

To perform the analysis, the following objects are provided:

* a numeric matrix of log<sub>2</sub> LFQ intensity data 
  (`a1_de` or `a9_de`).
* a numeric design matrix (`atcc_design`).
* a character vector with the contrasts of interest (`atcc_contrasts`).

```{r atccEfit, echo=TRUE, warning=FALSE}
# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
a1_efit <- limma_eBayes(a1_de, 
                        design = atcc_design, 
                        contrasts = atcc_contrasts)

a9_efit <- limma_eBayes(a9_de, 
                        design = atcc_design, 
                        contrasts = atcc_contrasts)
```

The results from `limma_eBayes` are extracted using `get_results` 
which allows the adjusted p-value cutoff and 
log<sub>2</sub> fold change cutoff for significance to be specified. 

To obtain the log<sub>2</sub> fold changes and adjusted p-values 
for each individual comparison specified, `type = "individual"` is used. 
This outputs a list of data.frames, one for each contrast. They can be accessed 
by subsetting the resulting list. In this case there is only 1 comparison of 
interest (`EV - WCL`), therefore the list of data.frames output will be of 
`length = 1`.

```{r atccDE5, echo=TRUE}
# extract results for individual comparisons defined in atcc_contrasts
a1_res <- get_results(efit = a1_efit, 
                      mat = a1_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[1]]

a9_res <- get_results(efit = a9_efit, 
                      mat = a9_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[1]]
```

In this example there is only one comparison of interest, so we are 
only interested in `type = individual`. However if there 
were multiple comparisons of interest, to get the 
overall differences for all the samples included in the design matrix and 
for all comparisons of interest, one can 
use `type = "overall"` for the result output.

```{r atccDE6, echo=TRUE, eval=FALSE}
# this example is not run in this vignette
# extract overall results for a1_efit
atcc_overall <- get_results(efit = a1_efit, 
                            mat = a1_de, 
                            p_val = 0.01, 
                            lfc = 0, 
                            type = "overall")
```

# Results

## ATCC10231

Differential abundance comparison of proteins in ATCC10231 EVs versus WCL.

```{r a1ResData, include=FALSE}
a1_res_short <- a1_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a1Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a1_res_short, 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```

## ATCC90028

Differential abundance comparison of proteins in ATCC90028 EVs versus WCL.

```{r a9ResData, include=FALSE}
a9_res_short <- a9_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a9Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a9_res_short, 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```

## Volcano plot

The results tables are used to construct volcano plots for ATCC10231 and 
ATCC9002. The `plot_volcano` function requires a data.frame input (`a1_res`) 
and specification of the column names that contain the data to be plotted 
(`adj.P.Val` and `logFC`). The `group` column in `a1_res` is used to separate 
the data into three groups that have different colours.

```{r a1Volcano, echo=TRUE}
a1_vol <- plot_volcano(a1_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 14), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 6))
```

```{r a9Volcano, echo=TRUE}
a9_vol <- plot_volcano(a9_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 12), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 6))
```

```{r atccVolcanoData, include=FALSE}
a1_volcano <- a1_vol + 
  scale_colour_manual(values = c("#D55E00",
                                 "#999999",
                                 "#0072B2"), 
                      labels = c("EV enriched", 
                                 "Not significant", 
                                 "WCL enriched")) + 
  theme(legend.title = element_blank())

a9_volcano <- a9_vol + 
  scale_colour_manual(values = c("#D55E00",
                                 "#999999",
                                 "#0072B2"), 
                      labels = c("EV enriched", 
                                 "Not significant", 
                                 "WCL enriched")) + 
  theme(legend.title = element_blank())
```

```{r atccVolcano, fig.cap=vol_cap, fig.wide=TRUE}
ggpubr::ggarrange(a1_volcano, a9_volcano,
                  labels = c("A", "B"),
                  ncol = 2,
                  nrow = 1,
                  align = "hv",
                  common.legend = TRUE,
                  legend = "bottom",
                  hjust = 0,
                  vjust = 1,
                  font.label = list(size = 24, colour = "black"))

vol_cap <- "Volcano plots for proteins quantified in EV and WCL. (A) ATCC10231 
            volcano plot. (B) ATCC90028 volcano plot."
```

## Log<sub>2</sub> LFQ intensity heatmap

The `a1_res` and `a9_res` data.frames are used to construct heatmaps based on 
the proteins that are significantly different across all both sample groups; 
EV and WCL.

There are two type of heatmaps: one for plotting log<sub>2</sub> LFQ intensity 
data and one for plotting log<sub>2</sub> fold change data. To plot an LFQ 
intensity heatmap, a numeric matrix must be used as the input.

In this case the `a1_res` data.frame is subset to remove all columns 
except a column with identifiers (e.g. UniProt accessions), 
log2 LFQ intensity data columns, and a logical significance column. 
Then the data.frame is 
filtered for significant proteins, the UniProt accession column is converted to 
rownames, the significance column is dropped, and the data.frame is converted 
to a numeric matrix.

For the `a9_res` data.frame, all columns are dropped except a column with 
identifiers (e.g. UniProt accessions), 
log2 LFQ intensity data columns, and the `EV_mean` column. Then the data.frame 
is filtered for top 100 proteins with the **lowest** mean EV LFQ intensity. 
Finally, the UniProt accession column is 
converted to rownames, the `EV_mean` column is dropped, and the data.frame 
is converted to a numeric matrix.
```{r heatmapData, echo=TRUE}
a1_htmp <- a1_res %>% 
  select(UP_accession, 
         matches("EV[0-9]"), 
         matches("WCL[0-9]"), 
         significant) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()

a9_htmp <- a9_res %>% 
  select(UP_accession, 
         matches("EV[0-9]"), 
         matches("WCL[0-9]"), 
         EV_mean) %>% 
  arrange(EV_mean) %>% 
  top_n(-100) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-EV_mean) %>% 
  as.matrix()
```

The `a1_htmp` heatmap is plotted with: 

```{r, echo=TRUE, eval=FALSE}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(a1_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right",
             cluster_split = TRUE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)
```

```{r a1Heatmap, fig.cap=htmp_cap, fig.height=8}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(a1_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right",
             cluster_split = TRUE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)

htmp_cap <- "Protein log<sub>2</sub> LFQ intensity heatmap. Data has been 
             centred around 0. ATCC10231 proteins significantly different in 
             abundance between EV and WCL."
```

The `a9_htmp` heatmap is plotted with (must use `cluster_split = FALSE` and 
`split_type = "cutree"` because data has missing values):

```{r, echo=TRUE, eval=FALSE}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

# a9_htmp has missing values, therefore must use cluster_split = FALSE and 
# split_type = "cutree"
plot_heatmap(a9_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "manhattan", 
             split_type = "cutree", 
             k = 5, 
             legend_pos = "right",
             cluster_split = FALSE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)
```

```{r a9Heatmap, fig.cap=htmp_cap, fig.height=8}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(a9_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "manhattan", 
             split_type = "cutree", 
             k = 5, 
             legend_pos = "right",
             cluster_split = FALSE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)

htmp_cap <- "Protein log<sub>2</sub> LFQ intensity heatmap. Data has been 
             centred around 0. Top 100 ATCC90028 EV proteins with the 
             lowest mean LFQ EV LFQ intensity."
```


## Log<sub>2</sub> fold change heatmap

To plot a log<sub>2</sub> fold change heatmap, a numeric matrix must be used 
as the input.

In this case, the `logFC`, `CGD_gene_name`, and `significant` columns from 
both the `a1_res` and `a9_res` data.frames are selected and combined into a 
single data.frame using the `CGD_gene_name` column as a reference. Then the 
data.frame is filtered for proteins significantly different in both strains.
Following this, the `CGD_gene_name` column 
is converted to rownames and the significance columns are dropped and the 
data.frame is converted to a numeric matrix.

```{r logfcHeatmapData, echo=TRUE}
# get data for log2 LFQ intensity heatmap
# find proteins signficantly different between EV and WCL from both strains
sig_both <- a1_res %>% 
  select(logFC, CGD_gene_name, significant) %>% 
  full_join(., select(a9_res, logFC, CGD_gene_name, significant), 
            by = "CGD_gene_name") %>% 
  rename(a1_lfc = logFC.x,
         a9_lfc = logFC.y, 
         a1_sig = significant.x, 
         a9_sig = significant.y) %>% 
  filter(a1_sig == TRUE & a9_sig == TRUE) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  select(a1_lfc, a9_lfc) %>% 
  as.matrix()
```

The heatmap is plotted with:

```{r echo=TRUE, eval=FALSE}
htmp2_params <- list(title = expression(bold(log[2]("FC"))), 
                     color_bar = "continuous", 
                     direction = "vertical", 
                     legend_height = unit(10, "cm"), 
                     title_position = "lefttop-rot", 
                     title_gp = grid::gpar(colour = "black", fontsize = 16), 
                     labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                     at = seq(-10, 10, 2))

htmp2 <- plot_heatmap(sig_both, 
                      plot = TRUE,
                      data_type = "log2fc", 
                      clust_fun = "euclidean", 
                      split_type = "kmeans", 
                      k = 5, 
                      legend_pos = "right", 
                      row_title_fontsize = 16, 
                      col_name_fontsize = 14, 
                      column_names_rot = 45, 
                      heatmap_legend_param = htmp2_params)
```

```{r logfcHeatmap, fig.cap=htmp2_cap, fig.small=TRUE}
htmp2_params <- list(title = expression(bold(log[2]("FC"))), 
                     color_bar = "continuous", 
                     direction = "vertical", 
                     legend_height = unit(10, "cm"), 
                     title_position = "lefttop-rot", 
                     title_gp = grid::gpar(colour = "black", fontsize = 16), 
                     labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                     at = seq(-10, 10, 2))

htmp2 <- plot_heatmap(sig_both, 
                      plot = TRUE,
                      data_type = "log2fc", 
                      clust_fun = "euclidean", 
                      split_type = "kmeans", 
                      k = 4, 
                      legend_pos = "right", 
                      row_title_fontsize = 16, 
                      col_name_fontsize = 14, 
                      column_names_rot = 45, 
                      heatmap_legend_param = htmp2_params)

htmp2_cap <- "Protein log<sub>2</sub> fold change heatmap."
```

Generally, proteins signficantly enriched in ATCC10231 EVs are also signficantly 
enriched in ATCC90028 EVs. Similarly, signficantly depleted EV proteins are
depleted in EVs from both strains.

# Session information {-}

The system on which this document was compiled was running 
pandoc v`r rmarkdown::pandoc_version()`. Here is output of 
`sessionInfo()`.

```{r sessionInfo}
sessionInfo()
```
