---
title: "Vignette title"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  This is the abstract.
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r knitrOpts, include=FALSE}
# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = FALSE,
                      warning = TRUE,
                      message = TRUE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")

# check for installation of packages requires to knit this vignette
req_pkgs <- c("BiocStyle", "ggpubr", "stringi", "DT")

check_pkgs <- function(x) {
  if(!requireNamespace(x, quietly = TRUE)) {
    stop(paste0("The package ",
                paste0(x),
                " is required to knit this document. 
                Please install it."))
  }
}

lapply(req_pkgs, check_pkgs)
```

# Preface

## Introduction

This vignette outlines the method used to analyse the label-free quantitative 
LC-MS/MS data obtained for _C. albicans_ (strain DAY286 yeast) 
extracellular vesicles (EVs) and whole cell lysates (WCL) by Dawson et 
al. (2019). The tools provided in this package, 
`r Githubpkg("csdaw/candidaev")`, allows the step-by-step reproduction of the 
results presented in the paper. 
The manuscript in its submitted form and the `.Rmarkdown` file used to 
generate it can found 
[here](https://github.com/csdaw/candidaev/tree/master/manuscript).

The analysis workflow used in this vignette is derived from the excellent 
**Bioconductor** package `r Biocpkg("DEP")`[^1]. Furthermore, some of the 
plotting functions available in `r Biocpkg("DEP")` have been modified for use 
in this package, `r Githubpkg("csdaw/candidaev")`. 

[^1]: Zhang, X., Smits, A. H., van Tilburg, G. B. A., Ovaa, H., Huber, W., & 
Vermeulen, M. (2018). Proteome-wide identification of ubiquitin interactions 
using UbIA-MS. _Nature Protocols, 13_(3), 530-550. 
[doi:10.1038/nprot.2017.147](https://doi.org/10.1038/nprot.2017.147)

## Experimental design

Extracellular vesicles (EVs) were isolated using differential 
ultracentrifugation from _C. albicans_ liquid cultures 
grown using the lab strain DAY286 (n = 4). 
Additionally, cells from these liquid cultures were separated and lysed to 
generate whole cell lysates (WCL). Each EV biological replicate was paired 
with a WCL replicate as they were derived from the same liquid culture.

Samples analysed in this vignette:

* DAY286 Yeast EV1
* DAY286 Yeast EV2
* DAY286 Yeast EV3
* DAY286 Yeast EV4
* DAY286 Yeast WCL1
* DAY286 Yeast WCL2
* DAY286 Yeast WCL3
* DAY286 Yeast WCL4

These samples were electrophoresed and the SDS-PAGE gel slices were 
reduced, alkylated, and digested with trypsin. The resulting peptides were 
extracted with acetonitrile, analysed by nano-LC-ESI-MS/MS, identified using 
MaxQuant, and quantified via the MaxLFQ algorithm in MaxQuant. 
The `proteinGroups.txt` file output was used for subsequent analyses.

## Data availability

The raw data was searched against the _C. albicans_ (SC5314) UniProt 
reference proteome (UP000000559) using MaxQuant version 1.6.0.16.  The 
`proteinGroups.txt` file analysed in this vignette 
can be easily accessed 
[here](https://github.com/csdaw/candidaev/tree/master/data-raw/lcms). 
It is also installed along with the 
`r Githubpkg("csdaw/candidaev")` package and can be loaded in R with 

```
data(yeast)
```

The LC-MS/MS raw data, peak data, and results files have been 
deposited in the ProteomeXchange Consortium database via the PRIDE partner 
repository with the data set identifier y and DOI x. 

# Data analysis

## Setup

Text.

```{r yeastInit}
yeast <- yeast %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

yeast_lfq <- convert_lfq(yeast, yeast_exp)

y1a <- plot_frequency2(yeast_lfq)

y1b <- plot_numbers2(yeast_lfq, yeast_exp) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggarrange(y1a, y1b, 
          labels = c("A", "B"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))

knitr::kable(summarise_lfq(yeast_lfq), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

```

Text.

```{r yeastFilt}
# filter for proteins identified in min 3/4 reps of EV or WCL
yeast_filt <- filter_na2(yeast_lfq, logic = "or", 
                         op = "<=", 
                         pat1 = "EV", val1 = 1, 
                         pat2 = "W", val2 = 1)

y2a <- plot_frequency2(yeast_filt)

y2b <- plot_numbers2(yeast_filt, yeast_exp) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

y2c_labels <- c(rep("EV", 4), rep("WCL", 4))

y2c <- plot_mds(yeast_filt, y2c_labels)

ggarrange(ggarrange(y2a, y2b, labels = c("A", "B"), ncol = 1, nrow = 2, 
                    font.label = list(size = 24, color = "black")), 
          y2c, 
          labels = c("", "C"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))
```

Text.

```{r yeastNorm}
yeast_norm <- normalizeCyclicLoess(yeast_filt)

y3a <- plot_normalization2(yeast_exp, yeast_filt, yeast_norm)

y3b_labels <- c(rep("EV", 4), rep("WCL", 4))

y3b <- plot_mds(yeast_norm, y3b_labels)

y3c <- plot_dendro(yeast_norm)

ggarrange(y3a, 
          ggarrange(y3b, y3c, labels = c("B", "C"), ncol = 1, nrow = 2, font.label = list(size = 24, color = "black")), 
          labels = c("A", ""), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))

```

Text.

```{r yeastFilt2}
# drop EV_1 and WCL_1
yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_1")]

# filter for proteins identified in min 2/3 reps of EV or WCL
yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

# create plots
y4a <- plot_frequency2(yeast_filt2)

y4b <- plot_numbers2(yeast_filt2, yeast_exp) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

y4c_labels <- c(rep("EV", 3), rep("WCL", 3))

y4c <- plot_mds(yeast_filt2, y4c_labels)

ggarrange(ggarrange(y4a, y4b, labels = c("A", "B"), ncol = 1, nrow = 2, 
                    font.label = list(size = 24, color = "black")), 
          y4c, 
          labels = c("", "C"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))



```

Text.

```{r yeastNorm2}
yeast_norm2 <- normalizeCyclicLoess(yeast_filt2)

y5a <- plot_normalization2(yeast_exp, yeast_filt2, yeast_norm2)

y5b_labels <- c(rep("EV", 3), rep("WCL", 3))

y5b <- plot_mds(yeast_norm2, y5b_labels)

y5c <- plot_dendro(yeast_norm2)

ggarrange(y5a, 
          ggarrange(y5b, y5c, labels = c("B", "C"), ncol = 1, nrow = 2, 
                    font.label = list(size = 24, color = "black")), 
          labels = c("A", ""), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))

```

```{r yeastVenn}
# filter for proteins identified in min 1/3 reps of EV
y_ev <- filter_na(yeast_norm2, op = "<=", 
                  pat = "EV", val = 2)

# filter for proteins identified in min 1/3 reps of WCL
y_wcl <- filter_na(yeast_norm2, op = "<=", 
                   pat = "W", val = 2)

y6 <- plot_venn(list("EV" = y_ev, "WCL" = y_wcl), 
                 use_uniprot = TRUE, type = "plot")

y6 <- as_ggplot(y6) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(y6)

```

Text

```{r yeastTop10}
# get top 10 most abundant protein exclusive to yeast EVs
# in descending order of abundance
yeast_top10 <- y_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "W", val = 3) %>% 
  select(-contains("W")) %>% 
  mutate(mean = rowMeans(select(., contains("EV")))) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  mutate(protein_name = match_id(id, uniprot, "UP_accession", "CGD_gene_name"), 
         GO_CC = match_id(id, uniprot, "UP_accession", "GO_CC"))

knitr::kable(yeast_top10, 
             caption = "This is a table caption", 
             digits = 1)
  

```

Text.

```{r yeastSum}
# explore percentage missing values in each sample
knitr::kable(summarise_lfq(yeast_norm2), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

```

TEXT.

```{r yeastSum2}

# should not impute with so many missing values
yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

knitr::kable(summarise_lfq(yeast_both), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

y7a <- grid::grid.grabExpr(plot_missval2(yeast_both))

y7b <- grid::grid.grabExpr(plot_detect2(yeast_both))

ggarrange(y7a, y7b, 
          labels = c("A", "B"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, colour = "black"))

```

TEXT. 

```{r yeastImpute, fig.width=4, fig.height=4}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
yeast_imp <- impute_QRILC(yeast_both)

plot_imputation2(yeast_exp, yeast_both, yeast_imp) + 
  theme_bw(base_size = 12)

```

TEXT.

```{r yeastDE}
# recombine imputed proteins and non-imputed proteins in matrix
yeast_de <- rbind(yeast_excl, yeast_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
y_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

y_design <- stats::model.matrix(~ 0 + T, data = y_samp)
colnames(y_design) <- c("EV", "WCL")

y_contrasts <- c("EV - WCL")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
y_efit <- limma_eBayes(yeast_de, y_design, y_contrasts)

# extract DE results 
yeast_res <- get_results(efit = y_efit, 
                         mat = yeast_de, 
                         p_val = 0.01, 
                         lfc = 0, 
                         type = "individual")[[1]]

yeast_res_short <- yeast_res %>% 
  select(CGD_gene_name, Protein_name, logFC, contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))

DT::datatable(yeast_res_short, 
              caption = "This is a table caption. Note that adjusted p values have been shortened
              to three significant figures for ease of display.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = DT::JS(
                                         "function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 40 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 40) + '...</span>' : data;",
                                         "}")), 
                                  list(targets = 0, 
                                       render = DT::JS("function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 12 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 12) + '...</span>' : data;",
                                         "}"))
                                  )
                )
              )


```




# Comparison to previous data


TEXT

```{r yeastComp}
g_list <- gilbona %>% 
  filter(EV1_peptides > 0 | EV2_peptides > 0 | EV3_peptides > 0) %>% 
  mutate(gn = match_id(UP_accession, uniprot, "UP_accession", "CGD_gene_name")) %>% 
  pull(gn)

v_list <- vargas %>% 
  filter(S11_peptides > 0) %>% 
  mutate(gn = match_id(UP_accession, uniprot, "UP_accession", "CGD_gene_name")) %>% 
  pull(gn)

w_list <- wolf %>% 
  filter(WT_pep > 0) %>% 
  mutate(gn = match_id(UP_accession, uniprot, "UP_accession", "CGD_gene_name")) %>% 
  pull(gn)

z_list_y <- zarnowski %>% 
  filter(Planktonic_NTS > 0) %>% 
  mutate(gn = match_id(UP_accession, uniprot, "UP_accession", "CGD_gene_name")) %>% 
  pull(gn)

y_ev_list <- match_id(rownames(y_ev), uniprot, "UP_accession", "CGD_gene_name", concat = FALSE)

yeast_comp <- list("This paper" = y_ev_list, "Gil-Bona" = g_list, "Vargas" = v_list, "Wolf" = w_list, "Zarnowski" = z_list_y)

upset(fromList(yeast_comp), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree", 
      queries = list(list(query = intersects, 
                          params = list(c("This paper", "Gil-Bona", "Vargas", "Wolf", "Zarnowski")), 
                          color = "limegreen", 
                          active = TRUE)))
yeast_comp_tab <- plot_venn(vlist = yeast_comp, use_uniprot = FALSE, type = "list") %>% 
  mutate(..values.. = lapply(..values.., function(x) paste(x, collapse = ", ")))

knitr::kable(yeast_comp_tab[1,], 
             caption = "A table caption")



```



















