---
title: "Marker analysis"
author: "Charlotte Dawson"
date: "2018-01-20"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    df_print: kable
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(collapse = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      echo = FALSE,
                      comment = "#>")
# use fig.path="../vignettes/figures" to save generated figures
library(limma)
library(dplyr)
library(ggplot2)
library(candidaev)
library(ggpubr)
library(UpSetR)

set.seed(1)
```

# Introduction


# Yeast DAY286 

## Analysis

Text.

```{r yeastData}
yeast <- yeast %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

yeast_lfq <- convert_lfq(yeast, yeast_exp)

# drop EV_1 and WCL_2
yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_2")]

# filter for proteins identified in min 2/3 reps of EV or WCL
yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- normalizeCyclicLoess(yeast_filt2)

# filter for proteins identified in min 1/3 reps of EV
y_ev <- filter_na(yeast_norm2, op = "<=", 
                  pat = "EV", val = 2)

# filter for proteins identified in min 1/3 reps of WCL
y_wcl <- filter_na(yeast_norm2, op = "<=", 
                   pat = "W", val = 2)

# should not impute with so many missing values
yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both)

# recombine imputed proteins and non-imputed proteins in matrix
yeast_de <- rbind(yeast_excl, yeast_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
y_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

y_design <- stats::model.matrix(~ 0 + T, data = y_samp)
colnames(y_design) <- c("EV", "WCL")

y_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
y_efit <- limma_eBayes(yeast_de, design = y_design, contrasts = y_contrasts)

# extract DE results
yeast_res <- get_results(efit = y_efit, mat = yeast_de, p_val = 0.01, lfc = 0, type = "individual")[[1]]


```

Text.

# Biofilm DAY286

## Analysis

Text.

```{r biofilmData}
biofilm <- biofilm %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

biofilm_lfq <- convert_lfq(biofilm, biofilm_exp)

# filter for proteins identified in min 4/5 reps of EV or WCL
biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- normalizeCyclicLoess(biofilm_filt)

# filter for proteins identified in min 1/5 reps of EV
b_ev <- filter_na(biofilm_norm, op = "<=", 
                  pat = "EV", val = 4)

# filter for proteins identified in min 1/5 reps of WCL
b_wcl <- filter_na(biofilm_norm, op = "<=", 
                   pat = "W", val = 4)

# should not impute with so many missing values
# filter for proteins with 4-5 NA values in EV or WCL
biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

# filter for proteins with min 3 valid values in EV and WCL
biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
biofilm_imp <- impute_QRILC(biofilm_both)

# recombine imputed proteins and non-imputed proteins in matrix
biofilm_de <- rbind(biofilm_excl, biofilm_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
b_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 5)))

b_design <- stats::model.matrix(~ 0 + T, data = b_samp)
colnames(b_design) <- c("EV", "WCL")

b_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
b_efit <- limma_eBayes(biofilm_de, design = b_design, contrasts = b_contrasts)

# extract DE results
biofilm_res <- get_results(efit = b_efit, mat = biofilm_de, p_val = 0.01, lfc = 0, type = "individual")[[1]]

```

Text.

# Different strains test
## Introduction

Aim is to determine whether identified potential biomarkers work in other 
*C. albicans* strains.

## Experimental design info
Strain used:

<div id="left">
- ATCC10231
- zzzzzz
</div>

<div id="right">
- ATCC90028
- zzzzzzz
</div>

## Analysis
    
### Prepare data

The untouched proteinGroups.txt file has `r nrow(atcc)` rows and `r ncol(atcc)`  columns.

Each of the `r nrow(atcc)` rows corresponds to a single protein group. 

```{r atccData}
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", Potential.contaminant != "+", Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)

atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

atcc_norm <- normalizeCyclicLoess(atcc_filt)

# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A10231_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, op = "<=", 
                     pat = "A10231_W", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_W", val = 2)

# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
atcc_excl <- filter_na4(atcc_norm, logic = "or", op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)

# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, logic = "and", op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

atcc_de <- rbind(atcc_excl, atcc_imp)

colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)

# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")

atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W", "A1_EV - A9_EV", "A1_W - A9_W")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "overall")

# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "individual")

a1_res <- atcc_ind[[1]]

a9_res <- atcc_ind[[2]]

```

TEXT.

```{r combinedVenn}
comp <- list("DAY286 Y" = rownames(y_ev), 
             "DAY286 B" = rownames(b_ev),
             "ATCC90028" = rownames(atcc9_ev), 
             "ATCC10231" = rownames(atcc1_ev))

comp2 <- lapply(comp, function(x) match_id(x, ref = uniprot, match = "UP_accession", new = "CGD_gene_name"))

f1 <- plot_venn(vlist = comp2, use_uniprot = FALSE, type = "plot")

f1 <- as_ggplot(f1) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

f1_overlap <- plot_venn(vlist = comp2, use_uniprot = FALSE, type = "list") %>% 
  filter(..count.. == 405) %>% 
  pull(..values..) %>% 
  unlist()

```


TEXT.

```{r combinedPCA, fig.height=6, fig.width=6}

pca_data <- cbind(atcc_de, 
                  biofilm_de[match(rownames(atcc_de), rownames(biofilm_de)), ])

pca_data <- cbind(pca_data, 
                  yeast_de[match(rownames(pca_data), rownames(yeast_de)), ])

colnames(pca_data)[13:28] <- c("B_EV1", "B_EV2", "B_EV3", "B_EV4", "B_EV5", 
                               "B_W1", "B_W2", "B_W3", "B_W4", "B_W5", 
                               "Y_EV1", "Y_EV2", "Y_EV3", 
                               "Y_W1", "Y_W2", "Y_W3")

f2 <- plot_mds(pca_data) + 
  geom_text(aes(label = colnames(pca_data)), hjust = 1.2, vjust = 0.5)

f3 <- NULL

ggarrange(f1, f2,
          f3, f3, 
          labels = c("A", "B", "C"), 
          ncol = 2, 
          nrow = 2, 
          font.label = list(size = 24, color = "black"), 
          heights = c(1,2))

```

TEXT.

```{r heatmapClustering, fig.width=3, fig.height=6}
clust_dist <- function(x) {
    dist <- cluster::daisy(x, metric = "gower")
    dist[is.na(dist)] <- max(dist, na.rm = TRUE)
    return(dist)
}

# combine logFC data from all 4 datasets
logfc_table <- a9_res %>% 
  select(logFC, CGD_gene_name) %>% 
  full_join(., select(a1_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  full_join(., select(yeast_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  full_join(., select(biofilm_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  rename(a9_lfc = logFC.x, 
         a1_lfc = logFC.y, 
         y_lfc = logFC.x.x, 
         b_lfc = logFC.y.y) %>% 
  select(CGD_gene_name, everything()) %>% 
  filter(CGD_gene_name %in% f1_overlap)

# filter for rows with min 1/4 valid values
# otherwise clustering will not work
logfc_table2 <- logfc_table %>% 
  filter_at(.vars = vars(contains("lfc")), 
            any_vars(!is.na(.))) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()

# excluded proteins
logfc_table_exc <- logfc_table %>% 
  filter_at(.vars = vars(contains("lfc")), 
            all_vars(is.na(.))) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()

# cluster rows
hr <- hclust(clust_dist(logfc_table2))

# define row clusters
logfc_cutree <- cutree(hr, h = max(hr$height/1.5))

# get colour palette equal to number of clusters
# and create vector of colours for side bar
clusterCols <- rainbow(length(unique(logfc_cutree)))
myClusterSideBar <- clusterCols[logfc_cutree]

# create palette and breaks for heatmap colours
my_palette <- colorRampPalette(c("blue", "white", "red")) (n = 15)
breaks <- seq(-8, 8, length.out = 16)

# draw heatmap
gplots::heatmap.2(logfc_table2, 
                  distfun = function(x) clust_dist(x), 
                  hclustfun = function(x) hclust(x), 
                  reorderfun = function(d,w) reorder(d, w, agglo.FUN = mean),
                  col = my_palette, 
                  breaks = breaks, 
                  RowSideColors = myClusterSideBar, 
                  trace = "none", 
                  na.color = "black", 
                  labRow = FALSE, 
                  srtCol = 0, 
                  dendrogram = "both",
                  denscol = "black", 
                  keysize = 1.3,
                  key.par=list(mgp=c(1.5, 0.5, 0),
                       mar=c(4, 2.5, 2.5, 0)))

```

TEXT.

# EV marker protein selection

TEXT.

```{r markerComparison}
marker_comp <- list("yeast" = yeast_res %>% 
                      filter(group == "EV up" | group == "EV ex") %>% 
                      pull(CGD_gene_name), 
                    "biofilm" = biofilm_res %>% 
                      filter(group == "EV up" | group == "EV ex") %>% 
                      pull(CGD_gene_name), 
                    "ATCC10231" = a1_res %>% 
                      filter(group == "A1_EV up" | group == "A1_EV ex") %>% 
                      pull(CGD_gene_name), 
                    "ATCC90028" = a9_res %>% 
                      filter(group == "A9_EV up" | group == "A9_EV ex") %>% 
                      pull(CGD_gene_name))

upset(fromList(marker_comp), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree")
marker_comp_tab <- plot_venn(vlist = marker_comp, use_uniprot = FALSE, type = "list")

```

TEXT.

```{r markerExtract}
# marker_candidates <- marker_comp_tab %>% 
#   filter(..count.. > 0 & ..count.. < 40) %>% 
#   pull(..values..) %>% 
#   set_names(c("both ex", "yev up bev ex", "yev ex bev up", "both up"))

marker_candidates <- marker_comp_tab %>% 
  filter(apply(.[, 1:4], 1, sum) == 4) %>% 
  pull(..values..) %>% 
  unlist() %>% 
  as.data.frame(stringsAsFactors = FALSE) %>% 
  rename(Gene = 1)

marker_longlist <- marker_candidates %>% 
  mutate(Protein = match_id(Gene, uniprot, "CGD_gene_name", "Protein_name"),
         DAY.Y = match_id(Gene, yeast_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         DAY.B = match_id(Gene, biofilm_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         A1 = match_id(Gene, a1_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         A9 = match_id(Gene, a9_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         TM = match_id(Gene, uniprot, "CGD_gene_name", "Transmembrane"), 
         SP = match_id(Gene, uniprot, "CGD_gene_name", "Signal_peptide")) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ signif(as.numeric(.), digits = 3))) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ case_when(is.na(.) == TRUE ~ "ex", 
                                     TRUE ~ as.character(.)))) %>% 
  mutate(TM = stringr::str_count(TM, "Helical"), 
         SP = case_when(grepl("SIGNAL", SP) ~ "Y", 
                        TRUE ~ ""), 
         TM = case_when(TM == 0 ~ "", 
                        TRUE ~ as.character(TM))) %>% 
  arrange(Gene)

marker_longlist[3, 7] <- "12;12"

protein_desc <- c("1,3-beta-glucanosyltransferase", 
                  "Rho family GTPase", 
                  "Multidrug transporter of ABC superfamily", 
                  "Major chitin synthase of yeast and hyphae", 
                  "GPI-anchored cell wall transglycosylase", 
                  "GPI-anchored cell wall protein", 
                  "Predicted P-type ATPase sodium pump", 
                  "ER oxidoreductin", 
                  "Long-chain fatty acid-CoA ligase", 
                  "Multicopper feroxidase", 
                  "High-affinity S-adenosylmethionine permease", 
                  "Surface protein similar to glycerol-3-phosphate dehydrogenase", 
                  "1,3-beta-glucan synthase", 
                  "High-affinity MFS glucose transporter", 
                  "Putative high-affinity MFS glucose transporter", 
                  "Putative mitochondrial phosphate transporter", 
                  "Glycolipid 2-alpha-mannosyltransferase", 
                  "Cell surface mannoprotein", 
                  "Mucin family adhesin-like protein", 
                  "Sphingolipid C9-methyltransferase", 
                  "S. cerevisiae ortholog is POM33, transmembrane nucleoporin", 
                  "S. cerevisiae ortholog is RTN1, reticulon protein", 
                  "Hexadecenal dehydrogenase", 
                  "S. cerevisiae ortholog is PUN1, plasma membrane protein", 
                  "1,3-beta-glucanosyltransferase", 
                  "GPI-anchored cell surface protein of unknown function", 
                  "Putative ion transporter", 
                  "Cell surface glycosidase", 
                  "Glycosidase", 
                  "Phospholipase B", 
                  "Plasma membrane ATPase", 
                  "Mitochondrial outer membrane porin", 
                  "G-protein of RAC subfamily", 
                  "Rho family GTPase", 
                  "Rho family GTPase", 
                  "Secreted aspartyl protease", 
                  "Rab family GTPase", 
                  "Protein required for normal cell wall, plasma membrane", 
                  "Protein involved in vacuolar inheritance", 
                  "S. cerevisiae ortholog is YCK2, casein kinase", 
                  "Palmitoyltransferase, putative vacuolar SNARE complex protein", 
                  "Rab family GTPase", 
                  "Putative vacuolar cation channel")
marker_longlist <- marker_longlist %>% 
  mutate(Protein = protein_desc)

                         
knitr::kable(marker_longlist)

```


