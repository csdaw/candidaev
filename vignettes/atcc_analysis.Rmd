---
title: "Vignette title"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  This is the abstract.
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r knit_options, include=FALSE}

# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")
```


# Preface

## Introduction

Xxx.

The raw proteinGroups.txt file on which these analyses are based can be accessed 
[here](). 

## Experimental design
Strain used:



# Data analysis
    
## Setup

The packages required for knitting this document are loaded and a specific seed 
is set for the steps requiring random number generation (imputation and clustering).

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
# load packages
library(candidaev)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(limma)
library(UpSetR)

# set seed for imputation, kmeans, MDS plot
set.seed(1)
```

The _C. albicans_ ATCC LC-MS/MS data set is provided as a data.frame in the 
`candidaev` package. 
It has `r nrow(atcc)` rows each of which corresponds to a single protein 
group[^1], and `r ncol(atcc)` columns. 
A key describing most of these columns can be found in the 
[MaxQuant documentation](http://www.coxdocs.org/doku.php?id=maxquant:table:proteingrouptable). 

[^1]: Each protein group comprises the group of proteins that could be reconstructed 
from a set of peptides by MaxQuant. In most cases this will be a single protein but 
sometimes there will be two or more proteins that could not be distinguished by the 
set of peptides.

```{r atccColumns, echo=TRUE, collapse=FALSE}
colnames(atcc)
```

## Data preparation

```{r atccInit}
# filter out reverse, contaminant proteins, and proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", Potential.contaminant != "+", Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)
```


First, filter any reverse and contaminant proteins. 
Then select only proteins identified by at least 2 unique peptides.

Now the dataset contains `r nrow(atcc_lfq)` proteins across the 12 samples.

```{r atccInit2, fig.cap="This is a figure caption"}
a1a <- plot_frequency2(atcc_lfq)

a1b <- plot_numbers2(atcc_lfq, atcc_exp) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

ggpubr::ggarrange(a1a, a1b,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"))

```


Table goes here.

More text goes here.

```{r atccInit3}

knitr::kable(summarise_lfq(atcc_lfq), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)
```

## Protein filtering (replicate quantification)

Filter for proteins identified in 2/3 reps of at least 1 condition.



```{r atccFilt}
atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

a2a <- plot_frequency2(atcc_filt)

a2b <- plot_numbers2(atcc_filt, atcc_exp) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

a2c_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

a2c <- plot_mds(atcc_filt, mat_labels = a2c_labels)

ggarrange(ggarrange(a2a, a2b, labels = c("A", "B"), ncol = 1, nrow = 2, 
                    font.label = list(size = 24, color = "black")), 
          a2c, 
          labels = c("", "C"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))

```

Reduces `r nrow(atcc_lfq)` proteins to `r nrow(atcc_filt)`.

## LFQ intensity normalisation

Text.

```{r atccNorm}
atcc_norm <- normalizeCyclicLoess(atcc_filt)

a3a <- plot_normalization2(atcc_exp, atcc_filt, atcc_norm)

a3b_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

a3b <- plot_mds(atcc_norm, mat_labels = a3b_labels)

a3c <- plot_dendro(atcc_norm)

ggarrange(a3a, 
          ggarrange(a3b, a3c, labels = c("B", "C"), ncol = 1, nrow = 2, font.label = list(size = 24, color = "black")), 
          labels = c("A", ""), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, color = "black"))

```

## ATCC strain protein comparison

Text.

```{r atccVenn}

# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A10231_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, op = "<=", 
                     pat = "A10231_W", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_W", val = 2)

a4 <- plot_venn(list("ATCC10231 EV" = atcc1_ev, "ATCC10231 WCL" = atcc1_w, 
                     "ATCC90028 EV" = atcc9_ev, "ATCC90028 WCL" = atcc9_w), 
                use_uniprot = TRUE, type = "plot")

a4 <- as_ggplot(a4) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(a4)

```

Text. 

```{r atcc1Top10}
# get top 10 most abundant protein exclusive to 10231 EVs
# in descending order of abundance
atcc1_top10 <- atcc1_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A10231_W", val = 3) %>% 
  select(id, contains("A10231_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A10231_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  mutate(protein_name = match_id(id = id, uniprot, "UP_accession", "CGD_gene_name"), 
         GO_CC = match_id(id, uniprot, "UP_accession", "GO_CC"))

knitr::kable(atcc1_top10, 
             caption = "This is a table caption", 
             digits = 1)
  

```

TEXT.

```{r atcc9Top10}
atcc9_top10 <- atcc9_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A90028_W", val = 3) %>% 
  select(id, contains("A90028_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A90028_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  mutate(protein_name = match_id(id = id, uniprot, "UP_accession", "CGD_gene_name"), 
         GO_CC = match_id(id, uniprot, "UP_accession", "GO_CC"))

knitr::kable(atcc9_top10, 
             caption = "This is a table caption", 
             digits = 1)
  
```

## Imputation of missing values

TEXT. 

```{r atccSum}
# explore percentage missing values in each sample
knitr::kable(summarise_lfq(atcc_norm), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

```

TEXT

```{r atccSum2}
# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
atcc_excl <- filter_na4(atcc_norm, logic = "or", op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)

# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, logic = "and", op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)



knitr::kable(summarise_lfq(atcc_both), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", "Median LFQ intensity", 
                           "SD", "CV", "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", "Percent NA"), 
             digits = 1)

a5a <- grid::grid.grabExpr(plot_missval2(atcc_both))

a5b <- grid::grid.grabExpr(plot_detect2(atcc_both))

ggarrange(a5a, a5b, 
          labels = c("A", "B"), 
          ncol = 2, 
          nrow = 1, 
          font.label = list(size = 24, colour = "black"))
```

TEXT.

```{r atccImpute}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

plot_imputation2(atcc_exp, atcc_both, atcc_imp) #a6

```

TEXT.

## Differential enrichment analysis with _limma_

```{r atccDE}
# recombine imputed proteins and non-imputed proteins in matrix
atcc_de <- rbind(atcc_excl, atcc_imp)

colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)

# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")

atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W", "A1_EV - A9_EV", "A1_W - A9_W")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "overall")

# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "individual")

a1_res <- atcc_ind[[1]]

a9_res <- atcc_ind[[2]]

aev_res <- atcc_ind[[3]]

aw_res <- atcc_ind[[4]]

```

# Results

## Volcano plot

TEXT.

```{r atccVolcanoData}




```

```{r atccVolcano}


```

## Heatmap

TEXT.

```{r atccHeatmap}

# atcc_htmp <- atcc_overall %>% 
#   select(1, 4:15, 24) %>% 
#   filter(significant == TRUE) %>% 
#   tibble::column_to_rownames(var = "UP_accession") %>% 
#   as.matrix()
# 
# plot_heatmap2(atcc_htmp, atcc_exp, uniprot, kmeans = TRUE, k = 5, clustering_distance = "euclidean", show_row_names = FALSE)

atcc_htmp3 <- atcc_overall %>% 
  select(1, 4:15, 24) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()

plot_heatmap(atcc_htmp3, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "cutree", 
             k = 5, 
             legend_pos = "right",
             cluster_split = FALSE, 
             split_order = c(1,2,5,4,3), 
             heatmap_legend_param = list(title = "legend title", 
                                         color_bar = "continuous", 
                                         direction = "vertical", 
                                         legend_width = unit(5, "cm"), 
                                         title_position = "lefttop-rot", 
                                         title_gp = grid::gpar(colour = "black", fontsize = 8), 
                                         labels_gp = grid::gpar(colour = "black", fontsize = 8), 
                                         at = seq(-10, 10, 2)))

```

TEXT.

```{r atccHeatmap2}

# atcc_htmp2 <- atcc_overall %>% 
#   select(1, matches("EV.vs.*W")) %>% 
#   filter_at(.vars = vars(contains("vs")),
#             all_vars(!is.na(.))) %>%
#   tibble::column_to_rownames(var = "UP_accession") %>% 
#   as.matrix()

atcc_htmp2 <- atcc_overall %>% 
  select(1, matches("EV.vs.*W"), 24) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()

plot_heatmap(atcc_htmp2, 
             plot = TRUE,
             data_type = "log2fc", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right", 
             split_order = c(2, 5, 1, 4, 3), 
             heatmap_legend_param = list(title = expression(bold(log[2]("FC"))), 
                                         color_bar = "continuous", 
                                         direction = "vertical", 
                                         legend_width = unit(5, "cm"), 
                                         title_position = "lefttop-rot", 
                                         title_gp = grid::gpar(colour = "black", fontsize = 8), 
                                         labels_gp = grid::gpar(colour = "black", fontsize = 8), 
                                         at = seq(-10, 10, 2))
             )
```

## Full results table

TEXT.

```{r markerComparison2}

marker_comp2 <- list("a1_ev up" = a1_res %>% 
                      filter(group == "A1_EV up") %>% 
                      pull(CGD_gene_name), 
                    "a1_ev ex" = a1_res %>% 
                      filter(group == "A1_EV ex") %>% 
                      pull(CGD_gene_name), 
                    "a9_ev up" = a9_res %>% 
                      filter(group == "A9_EV up") %>% 
                      pull(CGD_gene_name), 
                    "a9_ev ex" = a9_res %>% 
                      filter(group == "A9_EV ex") %>% 
                      pull(CGD_gene_name))

upset(fromList(marker_comp2), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree")
marker_comp_tab2 <- plot_venn(vlist = marker_comp2, use_uniprot = FALSE, type = "list")

knitr::kable(marker_comp_tab2, 
             caption = "A table caption")


```

## Potential marker proteins

TEXT.

```{r markerExtract2}
marker_candidates2 <- marker_comp_tab2 %>% 
  filter(..count.. > 0 & apply(.[, 1:4], 1, sum) > 1) %>% 
  pull(..values..) %>% 
  unlist()

test_can <- intersect(marker_candidates, marker_candidates2) %>% 
  stringr::str_extract_all(., "[^;]+") %>% 
  unlist()

test <- uniprot %>% 
  filter(CGD_gene_name %in% test_can)

DT::datatable(test, 
              caption = "This is a table caption.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(targets = c(7:10, 13:21), 
                                       render = DT::JS(
                                         "function(data, type, row, meta) {",
                                         "return type === 'display' && data.length > 40 ?",
                                         "'<span title=\"' + data + '\">' + data.substr(0, 40) + '...</span>' : data;",
                                         "}"))
                                  )
                )
              )

```




























