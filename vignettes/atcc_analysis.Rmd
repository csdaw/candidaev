---
title: "Vignette title"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  This is the abstract.
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r knitrOpts, include=FALSE}
# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = FALSE,
                      warning = TRUE,
                      message = TRUE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")
```

# Preface

## Introduction

This vignette outlines the method used to analyse the label-free quantitative 
LC-MS/MS data obtained for _C. albicans_ (strains ATCC10231 and ATCC90028) 
extracellular vesicles (EVs) and whole cell lysates (WCL) by Dawson et 
al. (2019). It has been written in such a way as to allow the step-by-step 
reproduction of the results presented in the paper using the tools provided 
in the package `r Githubpkg("csdaw/candidaev")`. The manuscript in its 
submitted form and the `.Rmarkdown` file used to generate it can found here.

The analysis workflow used in this vignette is derived from the excellent 
**Bioconductor** package `r Biocpkg("DEP")`[^1]. Furthermore, some of the 
plotting functions available in `r Biocpkg("DEP")` have been modified for use 
in this package, `candidaev`. 

[^1]: Zhang, X., Smits, A. H., van Tilburg, G. B. A., Ovaa, H., Huber, W., & 
Vermeulen, M. (2018). Proteome-wide identification of ubiquitin interactions 
using UbIA-MS. _Nature Protocols, 13_(3), 530-550. 
[doi:10.1038/nprot.2017.147](https://doi.org/10.1038/nprot.2017.147)

## Experimental design

Extracellular vesicles (EVs) were isolated using differential 
ultracentrifugation from _C. albicans_ liquid cultures 
from two clinical isolate strains; ATCC10231 (n = 3) and ATCC90028 (n = 3). 
Additionally, cells from these liquid cultures were seperated and lysed to 
generate whole cell lysates (WCL). Each EV biological replicate was paired 
with a WCL replicate as they were derived from the same liquid culture.

Samples analysed in this vignette:

* ATCC10231 EV1
* ATCC10231 EV2
* ATCC10231 EV3
* ATCC10231 WCL1 (W1)
* ATCC10231 WCL2 (W2)
* ATCC10231 WCL3 (W3)

* ATCC90028 EV1
* ATCC90028 EV2
* ATCC90028 EV3
* ATCC90028 WCL1 (W1)
* ATCC90028 WCL2 (W2)
* ATCC90028 WCL3 (W3)

These samples were electrophoresed and the SDS-PAGE gel slices were 
reduced, alkylated, and digested with trypsin. The resulting peptides were 
analysed by nano-LC-ESI-MS/MS, identified using MaxQuant, and quantified via 
the MaxLFQ algorithm in MaxQuant. The `proteinGroups.txt` file 
output was used for subsequent analyses.

## Data availability

The raw data was searched against the _C. albicans_ (SC5314) UniProt 
reference proteome (UP000000559) using MaxQuant version 1.6.0.16.  The 
`proteinGroups.txt` file analysed in this vignette 
can be easily accessed here. It is also installed along with the 
`r Githubpkg("csdaw/candidaev")` package and can be loaded in R with 

```
data(atcc)
```

The LC-MS/MS raw data, peak data, and results files have been 
deposited in the ProteomeXchange Consortium database via the PRIDE partner 
repository with the data set identifier y and DOI x. 

# Data analysis
    
## Setup

The packages required for knitting this document are loaded and a specific 
seed is set for the steps requiring random number generation (imputation 
and clustering).

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
# load packages
library(candidaev)
library(dplyr)
library(ggplot2)

# set seed for imputation, kmeans, MDS plot
set.seed(1)

# define ggplot2 default colour palette function
gg_colour <- function(n) {
  hues <- seq(15, 375, length = n + 1)
  grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

```

```{r randomDraws, include=FALSE}
# for results to be reproducible in seperate documents
# need to use set.seed AND need to perform same number of 
# 'random' draws in the same order as manuscript.Rmd
# DAY286 yeast
yeast_lfq <- yeast %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., yeast_exp)

yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_1")]

yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- limma::normalizeCyclicLoess(yeast_filt2)

yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both) # first set of random draws

# DAY286 biofilm
biofilm_lfq <- biofilm %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., biofilm_exp)

biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- limma::normalizeCyclicLoess(biofilm_filt)

biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

biofilm_imp <- impute_QRILC(biofilm_both) # second set of random draws
```


The _C. albicans_ ATCC LC-MS/MS data set is provided as a data.frame called 
`atcc` in this package. 
It has `r nrow(atcc)` rows each of which corresponds to a single protein 
group[^2], and `r ncol(atcc)` columns. 
A key describing most of these columns can be found in the 
[MaxQuant documentation](http://www.coxdocs.org/doku.php?id=maxquant:table:proteingrouptable). 
The `LFQ.intensity` columns hold the protein quantification data that is 
used for this analysis.

[^2]: Each protein group comprises the group of proteins that could be 
reconstructed from a set of peptides by MaxQuant. In most cases this will be 
a single protein but sometimes there will be two or more proteins that 
could not be distinguished by the set of peptides.

```{r atccColumns, echo=TRUE}
colnames(atcc)
```

`atcc_exp` is another data.frame provided in this package. It 
describes the experimental design underlying the `atcc` data set. 
The primary function `atcc_exp` is to provide info for labelling 
and grouping data in some of the plotting functions from 
the **Bioconductor** package `r Biocpkg("DEP")`, which have been 
modified for use in this package. `atcc_exp` supplies sample 
information (biological replicate, strain) for each 
`LFQ.intensity` column in the `atcc` data.frame.

It has the following structure. Notice that each row in the `label` 
column of `atcc_exp` is exactly the same as the names of the 
`LFQ.intensity` columns of `atcc`.

```{r atccexpTable}
knitr::kable(atcc_exp, 
             caption = "A table caption. A table caption.")
```

## Data preparation

First, the `atcc` data.frame is filtered to remove reverse proteins, 
contaminant proteins, and proteins identified by less than 2 unique peptides.

```{r atccInit, echo=TRUE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)
```

Then the data.frame is converted into a compact format using the `convert_lfq` 
function which performs the following:

1. Ensures the names of the `LFQ.intensity` columns in `atcc` exactly match 
   those in the `label` column of the experimental design, `atcc_exp`.
   
2. Returns a matrix containing only: the UniProt accession(s) and LFQ 
   intensities of each protein across the 12 samples. 
   
3. Log<sub>2</sub> transforms the LFQ intensities.

--------------------------------------------------------------------------------

The resulting matrix `atcc_lfq` still has `r nrow(atcc_lfq)` rows but only 
`r ncol(atcc_lfq)` columns, one for each LC-MS/MS sample. As it typical for 
shotgun proteomics data, the proteins in this data set 
are not quantified in every biological replicate of every strain.

```{r atccInit2, fig.cap=atccInit2_cap, fig.wide=TRUE}
freq1 <- plot_frequency2(atcc_lfq) + 
  scale_y_continuous(limits = c(0,600), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb1 <- plot_numbers2(atcc_lfq, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 2250), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq1, numb1,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccInit2_cap <- "This is a figure caption. This is the second sentence."
```


Table goes here.

More text goes here.

```{r atccInit3}
knitr::kable(sum_table(atcc_lfq), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

## Protein filtering (replicate quantification)

Filter for proteins identified in 2/3 reps of at least 1 condition.



```{r atccFilt, fig.cap=atccFilt_cap, fig.wide=TRUE}
atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

freq2 <- plot_frequency2(atcc_filt) + 
  scale_y_continuous(limits = c(0,400), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb2 <- plot_numbers2(atcc_filt, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 1750), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq2, numb2,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccFilt_cap <- "This is a figure caption. This is the second sentence."
```

Reduces `r nrow(atcc_lfq)` proteins to `r nrow(atcc_filt)`.

```{r atccFilt2, fig.cap=atccFilt2_cap, fig.small=TRUE}
mds1_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

plot_mds(atcc_filt, mat_labels = mds1_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-1.5, 0.75), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-4, 2), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccFilt2_cap <- "This is a figure caption. This is the second sentence."
```


## LFQ intensity normalisation

Text.

```{r atccNorm, fig.cap=atccNorm_cap, fig.height=7}
atcc_norm <- limma::normalizeCyclicLoess(atcc_filt)

plot_normalization2(atcc_exp, 
                    facet_labels = c(atcc_filt = "Before normalisation", 
                                     atcc_norm = "After normalisation"), 
                    atcc_filt, atcc_norm) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  xlab("Biological replicate") + 
  theme(plot.margin = margin(t = 0, l = 1.5, r = 1.5, b = 0, unit = "inches"))
  

atccNorm_cap <- "This is a figure caption. This is the second sentence."
```

Text.

```{r atccNorm2, fig.cap=atccNorm2_cap, fig.small=TRUE}
mds2_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

plot_mds(atcc_norm, mat_labels = mds2_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-0.8, 0.8), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-1, 1), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccNorm2_cap <- "This is a figure caption. This is the second sentence."
```


## ATCC strain protein comparison

Text.

```{r atccVenn, fig.cap=venn_cap}
# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A10231_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, op = "<=", 
                     pat = "A10231_W", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_W", val = 2)

# define comparison list for Venn diagram
venn1_comp <- list("A10231_EV" = atcc1_ev, 
                   "A10231_WCL" = atcc1_w, 
                   "A90028_EV" = atcc9_ev, 
                   "A90028_WCL" = atcc9_w)

# plot Venn diagram
venn1 <- plot_venn(venn1_comp, 
                   use_uniprot = TRUE, 
                   type = "plot", 
                   fontfamily = "sans", 
                   cat.fontfamily = "sans", 
                   cex = 1.9, 
                   cat.cex = 1.2, 
                   fill = gg_colour(4), 
                   alpha = c(rep(0.4, 4)))

# draw Venn diagram
grid::grid.draw(venn1)

venn_cap <- "This is a figure caption. This is the second sentence."
```

Text. 

```{r atcc1Top10}
# get top 10 most abundant protein exclusive to 10231 EVs
# in descending order of abundance
atcc1_top10 <- atcc1_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A10231_W", val = 3) %>% 
  select(id, contains("A10231_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A10231_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)

knitr::kable(atcc1_top10, 
             caption = "This is a table caption", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

TEXT.

```{r atcc9Top10}
atcc9_top10 <- atcc9_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A90028_W", val = 3) %>% 
  select(id, contains("A90028_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A90028_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)

knitr::kable(atcc9_top10, 
             caption = "This is a table caption", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

## Imputation of missing values

TEXT. 

```{r atccSum}
# explore percentage missing values in each sample
knitr::kable(sum_table(atcc_norm), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

TEXT

```{r atccSum2}
# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
atcc_excl <- filter_na4(atcc_norm, logic = "or", op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)

# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, logic = "and", op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)

knitr::kable(sum_table(atcc_both), 
             caption = "A table caption", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

TEXT.

```{r atccSum3, fig.cap=detect_cap, fig.wide=TRUE}
plot_detect2(atcc_both)

detect_cap <- "This is a figure caption."
```

TEXT. 

```{r atccSum4, fig.cap=missval_cap , fig.height=8}
plot_missval2(atcc_both)

missval_cap <- "This is a figure caption."
```


TEXT.

```{r atccImpute, fig.cap=imp_cap, fig.wide=TRUE}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

plot_imputation2(atcc_exp, facet_labels = c(atcc_both = "Before imputation", 
                                            atcc_imp = "After imputation"),  
                 atcc_both, atcc_imp)

imp_cap <- "This is a figure caption."
```

TEXT.

## Differential abundance analysis with _limma_

```{r atccDE}
# recombine imputed proteins and non-imputed proteins in matrix
atcc_de <- rbind(atcc_excl, atcc_imp)

colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)

# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", 
                                   "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")

knitr::kable(atcc_design, 
             caption = "A table caption.")
```

TEXT.

```{r atccDE2, include=FALSE}
# specify comparisons of interest
atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, 
                            p_val = 0.01, lfc = 0, type = "overall")

# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, 
                        p_val = 0.01, lfc = 0, type = "individual")

a1_res <- get_results(efit = atcc_efit, 
                      mat = atcc_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[1]]

a9_res <- get_results(efit = atcc_efit, 
                      mat = atcc_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[2]]
```


# Results

## ATCC90028

```{r a9ResData, include=FALSE}
a9_res_short <- a9_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a9Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a9_res_short, 
              caption = "This is a table caption. Note that adjusted p-values 
              have been shortened to three significant figures for ease of 
              display.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```


## ATCC10231 results table

```{r a1ResData, include=FALSE}
a1_res_short <- a1_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a1Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a1_res_short, 
              caption = "This is a table caption. Note that adjusted p-values 
              have been shortened to three significant figures for ease of 
              display.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```


## Volcano plot

TEXT.

```{r atccVolcanoData, include=FALSE}
a1_vol <- plot_volcano(a1_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 14), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 8)) + 
  scale_colour_manual(values = c("#D55E00",
                                 "#0072B2", 
                                 "#999999"), 
                      labels = c("EV enriched", 
                                 "WCL enriched", 
                                 "Not significant")) + 
  theme(legend.title = element_blank())

a9_vol <- plot_volcano(a9_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 12), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 8)) + 
  scale_colour_manual(values = c("#D55E00",
                                 "#0072B2", 
                                 "#999999"), 
                      labels = c("EV enriched", 
                                 "WCL enriched", 
                                 "Not significant")) + 
  theme(legend.title = element_blank())
```

```{r atccVolcano, fig.cap=vol_cap, fig.wide=TRUE}
ggpubr::ggarrange(a1_vol, a9_vol, 
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  align = "hv", 
                  common.legend = TRUE, 
                  legend = "bottom", 
                  hjust = 0, 
                  vjust = 1, 
                  font.label = list(size = 24, colour = "black"))

vol_cap <- "This is a figure caption."
```

## Heatmap

TEXT.

```{r atccHeatmap, fig.cap=htmp_cap, fig.height=8}
atcc_htmp <- atcc_overall %>% 
  select(UP_accession, 
         matches("A9_EV[0-9]"), matches("A1_EV[0-9]"), 
         matches("A9_W[0-9]"), matches("A1_W[0-9]"),  
         significant) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()

htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(atcc_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right",
             cluster_split = TRUE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)


htmp_cap <- "This is a figure caption."
```

TEXT.

```{r atccHeatmap2, fig.cap=htmp2_cap, fig.height=8}
atcc_htmp2 <- atcc_overall %>% 
  select(UP_accession, matches("EV.vs.*W"), significant) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()

htmp2_params <- list(title = expression(bold(log[2]("FC"))), 
                     color_bar = "continuous", 
                     direction = "vertical", 
                     legend_height = unit(10, "cm"), 
                     title_position = "lefttop-rot", 
                     title_gp = grid::gpar(colour = "black", fontsize = 16), 
                     labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                     at = seq(-10, 10, 2))

htmp2 <- ggpubr::as_ggplot(grid::grid.grabExpr(plot_heatmap(atcc_htmp2, 
                      plot = TRUE,
                      data_type = "log2fc", 
                      clust_fun = "euclidean", 
                      split_type = "kmeans", 
                      k = 5, 
                      legend_pos = "right", 
                      row_title_fontsize = 16, 
                      col_name_fontsize = 14, 
                      column_names_rot = 45, 
                      heatmap_legend_param = htmp2_params))) + 
  theme(plot.margin = margin(t = 0, l = 1.4, r = 1.4, b = 0, unit = "inches"))

htmp2


htmp2_cap <- "This is a figure caption."
```

# Session information {-}

The system on which this document was compiled was running 
pandoc v`r rmarkdown::pandoc_version()`. Here is output of 
`sessionInfo()`.

```{r sessionInfo}
sessionInfo()
```
























