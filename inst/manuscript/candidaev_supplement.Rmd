---
title: | 
   **Supplement to: Protein markers for *Candida albicans* EVs include
   claudin-like Sur7 family proteins and GTPases**
author: | 
   | Charlotte Dawson^a^, Donovan Garcia Ceron^a^, Harinda Rajapaksha^b^, 
     Pierre Faou^b^,
   | Marilyn Anderson^a^, Mark Bleackley^a^
date: | 
   | *^a^Department of Biochemistry and Genetics, La Trobe Institute for 
     Molecular Science, La Trobe University, 
     Melbourne, 3086, Victoria, Australia*
   | *^b^La Trobe Comprehensive Proteomics Platform, La Trobe Institute for 
     Molecular Science, La Trobe University, Melbourne, 
     3086, Victoria, Australia*
output: 
    bookdown::pdf_document2:
      latex_engine: xelatex
      fig_caption: yes
      number_sections: yes
      toc: no
      keep_tex: no
bibliography: "components/references.bib" 
csl: "components/taylor-and-francis-acs.csl"
link-citations: yes
linkcolor: black
fontsize: 12pt
geometry: margin=1in
classoption: letterpaper
mainfont: Times New Roman
linestretch: 1.5
header-includes:
  - \usepackage{titling}
  - \pretitle{\begin{center}\fontsize{14bp}{14bp}\selectfont}
  - \posttitle{\par\end{center}}
  - \preauthor{\begin{center}\fontsize{12bp}{12bp}\selectfont}
  - \postauthor{\par\end{center}}
  - \predate{\begin{center}\fontsize{10bp}{10bp}\selectfont}
  - \postdate{\par\end{center}}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \setlength{\headheight}{15pt}
  - \usepackage{float}
  - \let\origfigure\figure
  - \let\endorigfigure\endfigure
  - \renewenvironment{figure}[1][2]{\expandafter\origfigure\expandafter[H]}
    {\endorigfigure}
  - \newcommand{\beginsupplement}{
      \setcounter{table}{0} 
      \renewcommand{\thetable}{S\arabic{table}} 
      \setcounter{figure}{0} 
      \renewcommand{\thefigure}{S\arabic{figure}}
    }
  - \usepackage{caption}
  - \captionsetup{font={normalsize,stretch=1.3},labelfont=bf}
  - \usepackage{threeparttable}
---

**Corresponding author:** Mark Bleackley, m.bleackley@latrobe.edu.au

\newpage

```{r setup, include=FALSE}
# set knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# set chunk options
knitr::opts_chunk$set(collapse = TRUE, 
                      warning = FALSE, 
                      message = FALSE, 
                      echo = FALSE, 
                      comment = "#>")

# load libraries
library(candidaev)
library(tidyNano)
library(limma)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(kableExtra)
```


```{r yeast, include=FALSE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
yeast_lfq <- yeast %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., yeast_exp)

# drop EV_1 and WCL_1
yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_0", "WCL_0")]

# filter for proteins quantified in min 2/3 reps of EV or WCL
yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

# normalise LFQ intensities
yeast_norm2 <- normalizeCyclicLoess(yeast_filt2)

# filter for proteins quantified in min 1/3 reps of EV
# define 'EV proteins'
y_ev <- filter_na(yeast_norm2, op = "<=", 
                  pat = "EV", val = 2)

# filter for proteins quantified in min 1/3 reps of WCL
# define 'WCL proteins'
y_wcl <- filter_na(yeast_norm2, op = "<=", 
                   pat = "W", val = 2)

# won't impute with so many missing values
# separate EV/WCL exclusive proteins (don't impute) from 
# EV/WCL common proteins (impute)
yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

# use bpca method from pcaMethods for missing value imputation
yeast_imp <- pcaMethods::pca(yeast_both, method = "bpca")
yeast_imp <- pcaMethods::completeObs(yeast_imp)

# recombine imputed proteins and non-imputed proteins in matrix
yeast_de <- rbind(yeast_excl, yeast_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
y_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

y_design <- stats::model.matrix(~ 0 + T, data = y_samp)
colnames(y_design) <- c("EV", "WCL")

# define sample comparisons of interest
y_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
y_efit <- limma_eBayes(yeast_de, design = y_design, contrasts = y_contrasts)

# extract DE results
# adj.p.val cutoff is 0.01, log2FC cutoff is 1
yeast_res <- get_results(efit = y_efit, 
                         mat = yeast_de, 
                         p_val = 0.01, 
                         lfc = 1, 
                         type = "individual")[[1]]
```

```{r biofilm, include=FALSE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
biofilm_lfq <- biofilm %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., biofilm_exp)

# filter for proteins quantified in min 4/5 reps of EV or WCL
biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

# normalise LFQ intensities
biofilm_norm <- normalizeCyclicLoess(biofilm_filt)

# filter for proteins quantified in min 1/5 reps of EV
# define 'EV proteins'
b_ev <- filter_na(biofilm_norm, op = "<=", 
                  pat = "EV", val = 4)

# filter for proteins quantified in min 1/5 reps of WCL
# define 'WCL proteins'
b_wcl <- filter_na(biofilm_norm, op = "<=", 
                   pat = "W", val = 4)

# won't impute with so many missing values
# filter for proteins with 4-5 NA values in EV or WCL (don't impute)
biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

# filter for proteins with min 3 valid values in EV and WCL (impute)
biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

# use bpca method from pcaMethods for missing value imputation
biofilm_imp <- pcaMethods::pca(biofilm_both, method = "bpca")
biofilm_imp <- pcaMethods::completeObs(biofilm_imp)

# recombine imputed proteins and non-imputed proteins in matrix
biofilm_de <- rbind(biofilm_excl, biofilm_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
b_samp <- data.frame(T = rep(c("EV", "WCL"), each = 5))

b_design <- stats::model.matrix(~ 0 + T, data = b_samp)
colnames(b_design) <- c("EV", "WCL")

# define sample comparisons of interest
b_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
b_efit <- limma_eBayes(biofilm_de, design = b_design, contrasts = b_contrasts)

# extract DE results
# adj.p.val cutoff is 0.01, log2FC cutoff is 1
biofilm_res <- get_results(efit = b_efit, 
                           mat = biofilm_de, 
                           p_val = 0.01, 
                           lfc = 1, 
                           type = "individual")[[1]]
```

```{r atccBoth, include=FALSE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)

# filter for proteins quantified in min 2/3 reps of: 
# A1 EV or A1 WCL or A9 EV or A9 WCL
atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

# normalise LFQ intensities
atcc_norm <- normalizeCyclicLoess(atcc_filt)
```

```{r atcc1, include=FALSE}
# filter for proteins quantified in min 2/3 reps of ATCC10231 EV or WCL
a1_norm <- filter_na2(atcc_norm, logic = "or", op = "<=", 
                      pat1 = "A10231_EV", val1 = 1, 
                      pat2 = "A10231_W", val2 = 1)
a1_norm <- a1_norm[, -c(7:12)]

# filter for proteins quantified in min 1/3 reps of EV
# define 'EV proteins'
a1_ev <- filter_na(a1_norm, op = "<=", pat = "EV", val = 2)

# filter for proteins quantified in min 1/3 reps of WCL
# define 'WCL proteins'
a1_wcl <- filter_na(a1_norm, op = "<=", pat = "W", val = 2)

# won't impute with so many missing values
# separate EV/WCL exclusive proteins (don't impute) from
# EV/WCL common proteins (impute)
a1_excl <- filter_na2(a1_norm, logic = "or", op = "==",
                      pat1 = "EV", val1 = 3,
                      pat2 = "W", val2 = 3)

a1_both <- filter_na2(a1_norm, logic = "and", op = "<=",
                      pat1 = "EV", val1 = 2,
                      pat2 = "W", val2 = 2)

# use bpca method from pcaMethods for missing value imputation
a1_imp <- pcaMethods::pca(a1_both, method = "bpca")
a1_imp <- pcaMethods::completeObs(a1_imp)

# recombine imputed proteins and non-imputed proteins in matrix
a1_de <- rbind(a1_excl, a1_imp)
colnames(a1_de) <- gsub("A10231", "A1", colnames(a1_de))

# see limma user guide section 9.2 for more info about DE
# create design matrix
a1_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

a1_design <- stats::model.matrix(~ 0 + T, data = a1_samp)
colnames(a1_design) <- c("A1_EV", "A1_W")

# define sample comparisons of interest
a1_contrasts <- c("A1_EV - A1_W")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
a1_efit <- limma_eBayes(a1_de, design = a1_design, contrasts = a1_contrasts)

# extract DE results
# adj.p.val cutoff is 0.01, log2FC cutoff is 1
a1_res <- get_results(efit = a1_efit,
                      mat = a1_de,
                      p_val = 0.01,
                      lfc = 1,
                      type = "individual")[[1]]
```

```{r atcc9, include=FALSE}
# filter for proteins quantified in min 2/3 reps of ATCC90028 EV or WCL
a9_norm <- filter_na2(atcc_norm, logic = "or", op = "<=",
                      pat1 = "A90028_EV", val1 = 1,
                      pat2 = "A90028_W", val2 = 1)
a9_norm <- a9_norm[, -c(1:6)]

# filter for proteins quantified in min 1/3 reps of EV
# define 'EV proteins'
a9_ev <- filter_na(a9_norm, op = "<=", pat = "EV", val = 2)

# filter for proteins quantified in min 1/3 reps of WCL
# define 'WCL proteins'
a9_wcl <- filter_na(a9_norm, op = "<=", pat = "W", val = 2)

# can't impute with so many missing values
# separate EV/WCL exclusive proteins (don't impute) from
# EV/WCL common proteins (impute)
a9_excl <- filter_na2(a9_norm, logic = "or", op = "==",
                      pat1 = "EV", val1 = 3,
                      pat2 = "W", val2 = 3)

a9_both <- filter_na2(a9_norm, logic = "and", op = "<=",
                      pat1 = "EV", val1 = 2,
                      pat2 = "W", val2 = 2)

# use bpca method from pcaMethods for missing value imputation
a9_imp <- pcaMethods::pca(a9_both, method = "bpca")
a9_imp <- pcaMethods::completeObs(a9_imp)

# recombine imputed proteins and non-imputed proteins in matrix
a9_de <- rbind(a9_excl, a9_imp)
colnames(a9_de) <- gsub("A90028", "A9", colnames(a9_de))

# see limma user guide section 9.2 for more info about DE
# create design matrix
a9_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

a9_design <- stats::model.matrix(~ 0 + T, data = a9_samp)
colnames(a9_design) <- c("A9_EV", "A9_W")

# define sample comparisons of interest
a9_contrasts <- c("A9_EV - A9_W")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
a9_efit <- limma_eBayes(a9_de, design = a9_design, contrasts = a9_contrasts)

# extract DE results
# adj.p.val cutoff is 0.01, log2FC cutoff is 1
a9_res <- get_results(efit = a9_efit,
                      mat = a9_de,
                      p_val = 0.01,
                      lfc = 1,
                      type = "individual")[[1]]

# arguments for figure S1 export
fS1_args <- list(tiff = list(type = "cairo", compression = "lzw"))
```

# Supplementary data

\beginsupplement


```{r figureS1, fig.cap=fS1_cap, fig.width=5.45, fig.height=6, fig.path='figures/', dev=c('CairoPDF', 'tiff'), dev.args=fS1_args, dpi=600}
# construct figure 1
fS1_cap <- "\\textbf{Schematic of the workflow used for the isolation and 
           proteomic analysis of \\textit{C. albicans} EVs and the selection 
           of EV protein markers.} Steps 1 to 6 were performed for each of the 
           four strains examined in this study: DAY286 yeast, ATCC90028 yeast, 
           ATCC10231 yeast, and DAY286 biofilm. The results from the four 
           seperate analyses were combined (step 7) to identify proteins which 
           commonly appeared as EV marker candidates. The MISEV2018 criteria 
           for protein content-based EV characterisation and other 
           considerations were used to select the best \\textit{C. albicans} 
           EV marker proteins."

fS1 <- png::readPNG("figures/figures1.png")

# draw figure S1
ggplot() + 
  background_image(fS1)

# arguments for figure S2 export
fS2_args <- list(tiff = list(type = "cairo", compression = "lzw"))
```


```{r figureS2, fig.cap=fS2_cap, fig.height=5, fig.width=5, fig.path='figures/', dev=c('CairoPDF', 'CairoPS', 'tiff'), dev.args=fS2_args, dpi=600}
fS2_cap <- c("\\textbf{Size distribution of \\textit{C. albicans} EVs as 
              determined by nanoparticle tracking analysis (NTA).} A line plot 
              for each EV biological replicate from each strain is shown. Each 
              line plots represents the average of three technical replicates 
              and the dashed grey lines indicate 100 nm.")

figS2_labels <- c("ATCC10231", 
                  "ATCC90028", 
                  "DAY286 biofilm", 
                  "DAY286 yeast")

names(figS2_labels) <- c("ATCC10231", 
                         "ATCC90028", 
                         "Biofilm", 
                         "DAY286")

# average the nta technical replicate data
nta_techavg <- nta %>% 
  nanolyze(particle_size, Strain, Bio_rep, Dilution, 
           name = "Tech_rep", 
           param_var = True_count)

nta_techavg$Strain <- factor(nta_techavg$Strain, levels = c("DAY286",
                                                            "ATCC90028", 
                                                            "ATCC10231", 
                                                            "Biofilm"))

# plot nta distribution for each bio rep
nta_techavg %>% 
  ggplot(aes(x = particle_size, y = Tech_rep_mean, colour = Bio_rep)) + 
  geom_line(size = 0.5) + 
  geom_vline(xintercept = 100, colour = "#999999", linetype = "dashed") +
  facet_wrap(~ Strain, scales = "free", ncol = 2, nrow = 2, 
             labeller = labeller(Strain = figS2_labels)) + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        legend.position = "bottom", 
        plot.margin = margin(t = 0, l = 0, r = 0.1, b = 0, unit = "inches")) + 
  xlab(label = "Particle size (nm)") + 
  ylab(label = "Particles / mL") + 
  labs(colour = "Biological replicate")
```

\newpage

```{r tableS1Data}
# construct data.frame with nta experiment info
nta_metadata <- data.frame(id = c("ATCC10231_1", "ATCC10231_2", "ATCC10231_3", 
                                  "ATCC90028_1", "ATCC90028_2", "ATCC90028_3", 
                                  "Biofilm_1", "Biofilm_2", "Biofilm_3", 
                                  "Biofilm_4", "Biofilm_5", 
                                  "DAY286_1", "DAY286_2", "DAY286_3"), 
                           strain = c(rep("ATCC10231", 3), 
                                      rep("ATCC90028", 3), 
                                      rep("Biofilm", 5), 
                                      rep("DAY286", 3)), 
                           replicate = c(seq(1, 3), seq(1, 3), 
                                         seq(1, 5), seq(1, 3)), 
                           OD600 = c(0.455*20, 0.557*20, 0.615*20, 
                                     0.310*50, 0.337*50, 0.297*50, 
                                     rep(NA, 5), 
                                     36.2, 39.7, 34.0),
                           culture_vol = c(rep(150, 3),
                                           rep(150, 3), 
                                           rep(1000, 5), 
                                           rep(300, 3)), 
                           protein_yield = c(19.2, 28.2, 28.7, 
                                             42.4, 71.6, 58.4, 
                                             20.4, 19.8, 29.7, 19.3, 41.6, 
                                             21.9, 18.0, 22.4), 
                           protein_conc = c(0.192, 0.282, 0.287, 
                                            0.424, 0.716, 0.584, 
                                            0.204, 0.198, 0.297, 0.193, 0.416, 
                                            0.437, 0.360, 0.447), 
                           df = c(250, 750, 750, 
                                  1500, 3000, 3000, 
                                  3000, 2000, 2000, 3000, 6000, 
                                  1500, 1500, 1500), 
                           mean = c(248.5, 218.7, 217.9, 
                                    197.1, 233.1, 191.0, 
                                    119.4, 142.1, 143.3, 133.3, 120.9, 
                                    182.8, 174.5, 164.5), 
                           mode = c(171.9, 155.5, 140.2, 
                                    135.4, 156.7, 138.0, 
                                    100.5, 94.7, 103.1, 103.1, 97.5, 
                                    106.4, 99.2, 100.2), 
                           sd = c(120.1, 112.1, 110.0, 
                                  87.1, 90.7, 68.4, 
                                  47.4, 64.3, 70.2, 60.7, 47.4, 
                                  93.4, 93.9, 83.1), 
                           d10 = c(139.1, 110.2, 118.1, 
                                   122.4, 141.9, 126.0, 
                                   90.2, 88.8, 96.4, 93.2, 89.7, 
                                   97.8, 93.8, 93.0), 
                           d50 = c(211.9, 188.2, 180.3, 
                                   169.4, 209.3, 170.7, 
                                   105.6, 115.0, 110.9, 108.1, 105.9, 
                                   152.8, 147.3, 136.2),
                           d90 = c(393.0, 354, 354.4, 
                                   301.4, 381.1, 285.8, 
                                   151.5, 239.7, 240.8, 210.2, 171.2, 
                                   320.4, 308.0, 290.9),
                           sort_order = c(rep(3, 3), rep(2, 3), 
                                          rep(4, 5), rep(1, 3)), 
                           stringsAsFactors = FALSE)

# determine the total particle concentration for each biological replicate
nta_total <- nta_techavg %>% 
  nanocount(Strain, Bio_rep, Dilution, 
            param_var = Tech_rep_mean) %>% 
  tidyr::unite("id", Strain, Bio_rep) %>% 
  inner_join(., nta_metadata, by = "id") %>% 
  arrange(sort_order) %>% 
  select(strain, replicate, OD600, culture_vol, protein_yield, protein_conc, 
         Particle_count, mean, mode, sd) %>% 
  mutate(OD600 = case_when(is.na(OD600) == TRUE ~ "NA", 
                           TRUE ~ as.character(OD600)), 
         Particle_count = signif(Particle_count, digits = 3))
```

```{r tableS1}
tabS1_labs <- c("Biological\nreplicate", 
                "OD600", 
                "Culture vol.\n(mL)", 
                "Protein yield\n($\\mu$g)", 
                "Protein conc.\n($\\mu$g/mL)", 
                "Particle conc.\n(particles/mL)", 
                "Mean", 
                "Mode", 
                "SD")

tabS1_cap <- "\\textbf{Metadata for each EV isolation analysed in this study.} 
              The optical density (at 600 nm) and volume of each culture from 
              which the EVs were isolated is given. The protein and particle 
              concentration of the EVs along with the NTA size distribution 
              results for each biological replicate are also shown."

# construct a table of metadata for each EV biological replicate
tabS1 <- nta_total %>% 
  select(-strain) %>% 
  mutate_all(linebreak) %>% 
  knitr::kable(caption = tabS1_cap, 
               format = "latex", 
               booktabs = TRUE, 
               linesep = "", 
               col.names = linebreak(tabS1_labs), 
               escape = FALSE, 
               align = "l") %>% 
  kable_styling(latex_options = c("scale_down", 
                                  "HOLD_position")) %>% 
  add_header_above(c(" " = 6, "Particle diameter (nm)" = 3)) %>% 
  pack_rows("DAY286 yeast", 1, 3) %>% 
  pack_rows("ATCC90028", 4, 6) %>% 
  pack_rows("ATCC10231", 7, 9) %>% 
  pack_rows("DAY286 biofilm", 10, 14)

# export table S2 LaTeX code with \\ line endings removed in a text file
tabS1_clean <- gsub("\\\\\\\\\n", "\n", tabS1)

cat(tabS1_clean, file = "tables/table_S1.txt", sep = "\n")

# show table S1 in PDF output
tabS1
```

\newpage

```{r tableS2Data}
# make list of WCL sig. enriched and exclusive proteins for each strain
wcl_comp <- list("yeast" = yeast_res %>% 
                   filter(group == "WCL up" | group == "WCL ex") %>% 
                   pull(CGD_gene_name), 
                 "biofilm" = biofilm_res %>% 
                   filter(group == "WCL up" | group == "WCL ex") %>% 
                   pull(CGD_gene_name), 
                 "ATCC10231" = a1_res %>% 
                   filter(group == "A1_W up" | group == "A1_W ex") %>% 
                   pull(CGD_gene_name), 
                 "ATCC90028" = a9_res %>% 
                   filter(group == "A9_W up" | group == "A9_W ex") %>% 
                   pull(CGD_gene_name))

# get venn segments
wcl_comp_tab <- plot_venn(vlist = wcl_comp, 
                          use_uniprot = FALSE, 
                          type = "df")

# extract protein names from venn overlap
wcl_candidates <- wcl_comp_tab %>% 
  filter(apply(.[, 1:4], 1, sum) == 4) %>% 
  pull(..values..) %>% 
  unlist() %>% 
  as.data.frame(stringsAsFactors = FALSE) %>% 
  rename(Name = 1)

# construct table S2
wcl_longlist <- wcl_candidates %>% 
  mutate(DAY.Y = match_id(Name, yeast_res, "CGD_gene_name", 
                          "logFC", concat = TRUE, str_split = FALSE), 
         A9 = match_id(Name, a9_res, "CGD_gene_name", 
                       "logFC", concat = TRUE, str_split = FALSE), 
         A1 = match_id(Name, a1_res, "CGD_gene_name", 
                       "logFC", concat = TRUE, str_split = FALSE), 
         DAY.B = match_id(Name, biofilm_res, "CGD_gene_name", 
                          "logFC", concat = TRUE, str_split = FALSE), 
         TM = match_id(Name, uniprot, "CGD_gene_name", "Transmembrane"), 
         SP = match_id(Name, uniprot, "CGD_gene_name", "Signal_peptide")) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ sprintf(as.numeric(.), fmt = "%#.2f"))) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ case_when(. == "NA" ~ "ex", 
                                     TRUE ~ as.character(.)))) %>% 
  mutate(TM = stringr::str_count(TM, "Helical"), 
         SP = case_when(grepl("SIGNAL", SP) ~ "Y", 
                        TRUE ~ ""), 
         TM = case_when(TM == 0 ~ "", 
                        TRUE ~ as.character(TM))) %>% 
  rename("DAY Y" = DAY.Y, "DAY B" = DAY.B) %>% 
  arrange(Name)

# load .csv file with table S2 labels
wcl_labels <- read.csv("components/tableS2.csv", stringsAsFactors = FALSE) %>% 
  mutate(Function = case_when(Superscript == "a" ~ paste0(Function, 
                                                          footnote_marker_alphabet(1)), 
                              Superscript == "b" ~ paste0(Function, 
                                                          footnote_marker_alphabet(2)),
                              Superscript == "c" ~ paste0(Function, 
                                                          footnote_marker_alphabet(3)), 
                              TRUE ~ as.character(Function)), 
         VDM = c(rep("", 62)))

# add proper protein functions to table S2
# also add vesicle depleted supernatant info and 
# group proteins according to localisation
wcl_longlist2 <- match_id_multi(df = wcl_longlist, 
                                id = "Name", 
                                ref = wcl_labels, 
                                match = "Name", 
                                new = c("Function", "Loc_num", "VDM"), 
                                str_split = FALSE) %>% 
  select(Name, Function, everything()) %>% 
  arrange(Loc_num)
```

(ref:table1) [@gil-bona2015b]

(ref:footnote1) [@arnaud2005; @skrzypek2017]

(ref:footnote2) [@theuniprotconsortium2019]


```{r tableS2}
tabs2_cap <- "\\textbf{Candidate negative protein markers for 
              \\textit{C. albicans} EVs.} This list of proteins consists of 
              those that were found to be exclusive to whole cell lysate (WCL) 
              or significantly enriched in WCL across the four 
              \\textit{C. albicans} strains examined in this study. Proteins 
              are grouped according to their 
              subcellular localisation as annotated in the Candida Genome 
              Database (candidagenome.org) (ref:footnote1) unless otherwise 
              indicated. The log\\textsubscript{2} ratio of the abundance 
              (mean MaxQuant LFQ intensity) of each protein in EVs compared to 
              WCL for each strain is listed. A negative value indicates that a 
              protein was enriched in WCL compared to EV. \`\`ex\" indicates 
              where a protein was only quantified in the WCL fraction and not 
              in EVs for that strain. The \`\`TM\" column indicates the number 
              of transmembrane domains for each protein as annotated in 
              UniProtKB. \`\`SP\" indicates whether a protein is annotated as 
              having a signal peptide according to UniProt. \`\`VDM\" shows 
              whether a protein has previously been detected in 
              vesicle-depleted culture media (i.e. the proteins may also be in 
              the soluble secretome) (ref:table1). Underlined proteins are 
              those identified as the best candidates for negative
              EV markers according to the criteria depicted in 
              Supplementary Figure S1."

# draw table S2
tabS2 <- knitr::kable(wcl_longlist2[, -9], 
                      caption = tabs2_cap, 
                      format = "latex", 
                      booktabs = TRUE, 
                      longtable = TRUE, 
                      linesep = "", 
                      escape = FALSE) %>% 
  row_spec(row = c(26, 32, 36:38, 42, 58), underline = TRUE) %>% 
  add_header_above(c(" " = 2, 
                     "log\\\\textsubscript{2}(fold change) EV vs WCL" = 4, 
                     " " = 3), escape = FALSE) %>% 
  kable_styling(font_size = 8, 
                latex_options = c("HOLD_position")) %>% 
  pack_rows("Cytoplasm", 1, 13) %>% 
  pack_rows("Cytosol and mitochondria", 14, 16) %>% 
  pack_rows("Mitochondria", 17, 32) %>% 
  pack_rows("Nucleus", 33, 34) %>% 
  pack_rows("Vacuole", 35, 38) %>% 
  pack_rows("Cell wall, cell surface, fungal biofilm matrix", 39, 50) %>% 
  pack_rows("Proteasome", 51, 54) %>% 
  pack_rows("Cytoplasmic stress granule", 55, 56) %>% 
  pack_rows("Peroxisome", 57, 57) %>% 
  pack_rows("Actin cortical patch", 58, 58) %>% 
  pack_rows("Unknown", 59, 62) %>% 
  footnote(alphabet = c("Protein localisation was inferred from sequence 
                         similarity with \\\\textit{S. cerevisiae} homolog as 
                         annotated in the Candida Genome Database 
                         (ref:footnote1)", 
                        "Protein localisation was obtained from the GO Cellular
                        Component annotation in the \\\\textit{C. albicans} 
                        UniProt reference proteome UP000000559 (ref:footnote2).", 
                        "Protein and has no Cellular Component annotation in 
                         the Candida Genome Database or UniProt reference 
                        proteome."), 
           escape = FALSE, 
           threeparttable = TRUE)


# export table S2 LaTeX code with \\ line endings removed in a text file
tabS2_clean <- gsub("\\\\\\\\\n", "\n", tabS2)

cat(tabS2_clean, file = "tables/table_S2.txt", sep = "\n")

# show table S2 in PDF output
tabS2
```

\newpage

# References

<div id="refs"></div>

