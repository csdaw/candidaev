#' Visualise intensities of proteins with missing values
#'
#' @description \code{plot_detect2} generates density and cumulative sum plots
#' of protein intensities for proteins with and without missing values.
#'
#' This function has been taken directly from the \code{plot_detect} function
#' in the \href{http://doi.org/10.18129/B9.bioc.DEP}{DEP} package and then
#' modified for use in this package.
#'
#' \href{http://doi.org/10.18129/B9.bioc.DEP}{DEP} is distributed with the Artistic-2.0 license
#' which requires any source code modifications to be clearly stated.
#'
#' \code{plot_detect2} includes the following modifications of \code{plot_detect}:
#'
#' \itemize{
#' \item Dependance on a "SummarizedExperiment" object as input has been removed.
#' Instead the input has been changed to a numeric matrix.
#' \item Use of \code{theme_DEP1()} has been replaced with \code{theme_bw()}
#' \item x axis labels have been changed to "log2 LFQ intensity".
#' }
#'
#' @param mat numeric matrix: must have missing values
#'
#' @return Returns density and cumulative sum plots of protein intensities for
#' proteins with and without missing values
#' (generated by \code{\link[ggplot2]{ggplot}}).
#'
#' @examples
#' # load dplyr
#' library(dplyr)
#'
#' # load a proteinGroups data.frame supplied with this package
#' my_proteinGroups <- atcc
#'
#' # load its corresponding experimental design
#' my_expDesign <- atcc_exp
#'
#' # filter for proteins identified with minimum 3 unique peptides
#' # and convert to numeric matrix
#' my_lfq <- my_proteinGroups %>%
#'   filter(Unique.peptides >= 3) %>%
#'   convert_lfq(., my_expDesign)
#'
#' # filter for proteins quantified in min 2/3 reps of
#' # at least 1 sample group
#' my_filt <- my_lfq %>%
#'   filter_na4(., logic = "or", op = "<=",
#'              pat1 = "A10231_EV", val1 = 1,
#'              pat2 = "A10231_W", val2 = 1,
#'              pat3 = "A90028_EV", val3 = 1,
#'              pat4 = "A90028_W", val4 = 1)
#'
#' # normalise LFQ intensities
#' my_norm <- limma::normalizeCyclicLoess(my_filt)
#'
#' # generate density and cumulative sum plots
#' plot_detect2(my_norm)
#'
#' @export
plot_detect2 <- function(mat) {
  # show error if inputs is not a matrix
  assertthat::assert_that(is.matrix(mat))

  # show error if there are no missing values
  if(!any(is.na(mat))) {
    stop("No missing values in '", deparse(substitute(mat)), "'",
         call. = FALSE)
  }

  # Get a long data.frame of the assay data annotated with sample info
  df <- mat %>%
    data.frame() %>%
    tibble::rownames_to_column() %>%
    tidyr::gather(ID, val, -rowname)

  # get a summary table with mean protein intensities and
  # indication whether the protein has missing values
  stat <- df %>%
    group_by(rowname) %>%
    summarise(mean = mean(val, na.rm = TRUE), missval = any(is.na(val)))

  # calculate cumulative sums
  cumsum <- stat %>%
    group_by(missval) %>%
    arrange(mean) %>%
    mutate(num = 1, cs = cumsum(num), cs_frac = cs/n())

  # plot the densities and cumalitive sums for
  # proteins with and without missing values
  p1 <- ggplot(stat, aes(mean, col = missval)) +
    geom_density(na.rm = TRUE) +
    labs(x = expression(log[2]~"LFQ intensity"), y = "Density") +
    guides(col = guide_legend(title = "Missing values")) +
    theme_bw(base_size = 12)
  p2 <- ggplot(cumsum, aes(mean, cs_frac, col = missval)) +
    geom_line() +
    labs(x = expression(log[2]~"LFQ intensity"), y = "Cumulative fraction") +
    guides(col = guide_legend(title = "Missing values")) +
    theme_bw(base_size = 12)
  gridExtra::grid.arrange(p1, p2, ncol = 1)
}
