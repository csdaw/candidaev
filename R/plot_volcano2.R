#' Volcano plot
#'
#' \code{plot_volcano} generates a volcano plot for a specified contrast.
#'
#' @param mat SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' (output from \code{test_diff()} and \code{add_rejections()}).
#' @param exd Character(1),
#' Specifies the contrast to plot.
#' @param unip Description.
#' @param label_size Integer(1),
#' Sets the size of name labels.
#' @param add_names Logical(1),
#' Whether or not to plot names.
#' @param lab Description
#' Description
#' @param adjusted Logical(1),
#' Whether or not to use adjusted p values.
#' @param plot Logical(1),
#' If \code{TRUE} (default) the volcano plot is produced.
#' Otherwise (if \code{FALSE}), the data which the
#' volcano plot is based on are returned.
#' @return A volcano plot (generated by \code{\link[ggplot2]{ggplot}})
#' @examples
#' \dontrun{
#' # Load example
#' data <- UbiLength
#' data <- data[data$Reverse != "+" & data$Potential.contaminant != "+",]
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' # Make SummarizedExperiment
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' # Filter, normalize and impute missing values
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' # Test for differentially expressed proteins
#' diff <- test_diff(imputed, "control", "Ctrl")
#' dep <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' # Plot volcano
#' plot_volcano(dep, 'Ubi6_vs_Ctrl', label_size = 5, add_names = TRUE)
#' plot_volcano(dep, 'Ubi6_vs_Ctrl', label_size = 5,
#'    add_names = TRUE, adjusted = TRUE)
#' plot_volcano(dep, 'Ubi6_vs_Ctrl', add_names = FALSE)
#' plot_volcano(dep, 'Ubi4_vs_Ctrl', label_size = 5, add_names = TRUE)
#' }
#' @importFrom grid unit
#' @export
plot_volcano2 <- function(mat, exd, unip, label_size = 3,
                          add_names = TRUE, lab = NULL, adjusted = FALSE, plot = TRUE) {
  # Show error if inputs are not the required classes
  if(is.integer(label_size)) label_size <- as.numeric(label_size)
  assertthat::assert_that(is.matrix(mat),
                          is.data.frame(exd),
                          assert_exd(exd),
                          is.data.frame(unip),
                          is.numeric(label_size),
                          length(label_size) == 1,
                          is.logical(add_names),
                          length(add_names) == 1,
                          is.logical(adjusted),
                          length(adjusted) == 1,
                          is.logical(plot),
                          length(plot) == 1)

  # Show error if inputs do not contain required columns
  if(any(!c("logFC", "AveExpr", "t", "P.Value", "adj.P.Val", "B", "significant") %in% colnames(mat))) {
    stop(paste0("'logFC', 'AveExpr', 't', 'P.Value', 'adj.P.Val', 'B', and/or 'significant'
                columns are not present in '",
                deparse(substitute(mat)),
                "'.\nRun combine_result() to obtain required columns."),
         call. = FALSE)
  }

  # Convert mat into correct format with gene names
  row_data <- mat %>%
    as.data.frame()
  row_data$significant <- row_data$significant == 1
  row_data$name <- match_id(row.names(row_data), unip, "UP_accession", "CGD_gene_name")

  # Generate a data.frame containing all info for the volcano plot
  lfc <- grep("logFC", colnames(row_data))
  if(adjusted) {
    p_values <- grep("adj.P.Val", colnames(row_data))
  } else {
    p_values <- grep("P.Value", colnames(row_data))
  }
  signif <- grep("significant", colnames(row_data))
  df <- data.frame(x = row_data[, lfc],
                   y = -log10(row_data[, p_values]),
                   significant = row_data[, signif],
                   name = row_data$name) %>%
    filter(!is.na(significant)) %>%
    arrange(significant)

  name1 <- unique(exd[["condition"]])[1]
  name2 <- unique(exd[["condition"]])[2]

  # Plot volcano with or without labels
  p <- ggplot(df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_point(aes(col = significant)) +
    geom_text(data = data.frame(), aes(x = c(Inf, -Inf),
                                       y = c(-Inf, -Inf),
                                       hjust = c(1, 0),
                                       vjust = c(-1, -1),
                                       label = c(name1, name2),
                                       size = 5,
                                       fontface = "bold")) +
    labs(title = paste0(name1, " vs ", name2),
         x = expression(log[2]~"Fold change")) +
    theme_bw() +
    theme(legend.position = "none") +
    scale_color_manual(values = c("TRUE" = "black", "FALSE" = "grey"))
  if(add_names & length(lab) > 0) {
    p <- p + ggrepel::geom_text_repel(data = filter(df, name %in% lab),
                                      aes(label = name),
                                      size = label_size,
                                      box.padding = unit(0.1, 'lines'),
                                      point.padding = unit(0.1, 'lines'),
                                      segment.size = 0.5)
  } else if(add_names & length(lab) > 0) {
    p <- p + ggrepel::geom_text_repel(data = filter(df, significant == TRUE),
                                      aes(label = name),
                                      size = label_size,
                                      box.padding = unit(0.1, 'lines'),
                                      point.padding = unit(0.1, 'lines'),
                                      segment.size = 0.5)
  }
  if(adjusted) {
    p <- p + labs(y = expression(-log[10]~"Adjusted p-value"))
  } else {
    p <- p + labs(y = expression(-log[10]~"P-value"))
  }
  if(plot) {
    return(p)
  } else {
    df <- df %>%
      select(name, x, y, significant) %>%
      arrange(desc(x))
    colnames(df)[c(1,2,3)] <- c("protein", "log2_fold_change", "p_value_-log10")
    if(adjusted) {
      colnames(df)[3] <- "adjusted_p_value_-log10"
    }
    return(df)
  }
}
