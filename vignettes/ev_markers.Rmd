---
title: "Marker analysis"
author: "Charlotte Dawson"
date: "2018-01-20"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    df_print: kable
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(collapse = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      echo = FALSE,
                      comment = "#>")
# use fig.path="../vignettes/figures" to save generated figures
library(limma)
library(dplyr)
library(ggplot2)
library(candidaev)
library(ggpubr)
library(UpSetR)

set.seed(1)
```

# Introduction


# Yeast DAY286 

## Analysis

Text.

```{r yeastData}
yeast <- yeast %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

yeast_lfq <- convert_lfq(yeast, yeast_exp)

# drop EV_1 and WCL_2
yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_2")]

# filter for proteins identified in min 2/3 reps of EV or WCL
yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- normalizeCyclicLoess(yeast_filt2)

# filter for proteins identified in min 1/3 reps of EV
y_ev <- filter_na(yeast_norm2, op = "<=", 
                  pat = "EV", val = 2)

# filter for proteins identified in min 1/3 reps of WCL
y_wcl <- filter_na(yeast_norm2, op = "<=", 
                   pat = "W", val = 2)

# should not impute with so many missing values
yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both)

# recombine imputed proteins and non-imputed proteins in matrix
yeast_de <- rbind(yeast_excl, yeast_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
y_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 3)))

y_design <- stats::model.matrix(~ 0 + T, data = y_samp)
colnames(y_design) <- c("EV", "WCL")

y_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
y_efit <- limma_eBayes(yeast_de, design = y_design, contrasts = y_contrasts)

# extract DE results
yeast_res <- get_results(efit = y_efit, mat = yeast_de, p_val = 0.01, lfc = 0, type = "individual")[[1]]


```

Text.

# Biofilm DAY286

## Analysis

Text.

```{r biofilmData}
biofilm <- biofilm %>% 
  filter(Reverse != "+", Potential.contaminant != "+", 
         Only.identified.by.site != "+", Unique.peptides >= 2)

biofilm_lfq <- convert_lfq(biofilm, biofilm_exp)

# filter for proteins identified in min 4/5 reps of EV or WCL
biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- normalizeCyclicLoess(biofilm_filt)

# filter for proteins identified in min 1/5 reps of EV
b_ev <- filter_na(biofilm_norm, op = "<=", 
                  pat = "EV", val = 4)

# filter for proteins identified in min 1/5 reps of WCL
b_wcl <- filter_na(biofilm_norm, op = "<=", 
                   pat = "W", val = 4)

# should not impute with so many missing values
# filter for proteins with 4-5 NA values in EV or WCL
biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

# filter for proteins with min 3 valid values in EV and WCL
biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
biofilm_imp <- impute_QRILC(biofilm_both)

# recombine imputed proteins and non-imputed proteins in matrix
biofilm_de <- rbind(biofilm_excl, biofilm_imp)

# see limma user guide section 9.2 for more info about DE
# create design matrix
b_samp <- data.frame(T = (rep(c("EV", "WCL"), each = 5)))

b_design <- stats::model.matrix(~ 0 + T, data = b_samp)
colnames(b_design) <- c("EV", "WCL")

b_contrasts <- c("EV - WCL")

# make all pair-wise comparisons between EV and WCL
# and perform limma::eBayes()
b_efit <- limma_eBayes(biofilm_de, design = b_design, contrasts = b_contrasts)

# extract DE results
biofilm_res <- get_results(efit = b_efit, mat = biofilm_de, p_val = 0.01, lfc = 0, type = "individual")[[1]]

```

Text.

# Different strains test
## Introduction

Aim is to determine whether identified potential biomarkers work in other 
*C. albicans* strains.

## Experimental design info
Strain used:

<div id="left">
- ATCC10231
- zzzzzz
</div>

<div id="right">
- ATCC90028
- zzzzzzz
</div>

## Analysis
    
### Prepare data

The untouched proteinGroups.txt file has `r nrow(atcc)` rows and `r ncol(atcc)`  columns.

Each of the `r nrow(atcc)` rows corresponds to a single protein group. 

```{r atccData}
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", Potential.contaminant != "+", Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)

atcc_filt <- filter_na4(atcc_lfq, "or", "<=", 
                        pat1 = "A10231_EV", 1, 
                        pat2 = "A10231_W", 1, 
                        pat3 = "A90028_EV", 1, 
                        pat4 = "A90028_W", 1)

atcc_norm <- normalizeCyclicLoess(atcc_filt)

# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A10231_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, op = "<=", 
                     pat = "A10231_W", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_EV", val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, op = "<=", 
                      pat = "A90028_W", val = 2)

# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
atcc_excl <- filter_na4(atcc_norm, logic = "or", op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)

# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, logic = "and", op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)

# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

atcc_de <- rbind(atcc_excl, atcc_imp)

colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)

# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")

atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W", "A1_EV - A9_EV", "A1_W - A9_W")

# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "overall")

# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, p_val = 0.01, lfc = 0, type = "individual")

a1_res <- atcc_ind[[1]]

a9_res <- atcc_ind[[2]]

```

TEXT.

```{r combinedVenn}
comp <- list("DAY286 Y" = rownames(y_ev), 
             "DAY286 B" = rownames(b_ev),
             "ATCC90028" = rownames(atcc9_ev), 
             "ATCC10231" = rownames(atcc1_ev))

comp2 <- lapply(comp, function(x) match_id(x, ref = uniprot, match = "UP_accession", new = "CGD_gene_name"))

f1 <- plot_venn(vlist = comp2, use_uniprot = FALSE, type = "plot")

f1 <- as_ggplot(f1) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(f1)

f1_overlap <- plot_venn(vlist = comp2, use_uniprot = FALSE, type = "list") %>% 
  filter(..count.. == 405) %>% 
  pull(..values..) %>% 
  unlist()

```


TEXT.

```{r combinedPCA}
test <- cbind(atcc_de, 
              biofilm_de[match(rownames(atcc_de), rownames(biofilm_de)), ])

colnames(test)[13:22] <- c("B_EV1", "B_EV2", "B_EV3", "B_EV4", "B_EV5", "B_W1", "B_W2", "B_W3", "B_W4", "B_W5")

test2 <- cbind(test, 
               yeast_de[match(rownames(test), rownames(yeast_de)), ])

colnames(test2)[23:28] <- c("Y_EV1", "Y_EV2", "Y_EV3", "Y_W1", "Y_W2", "Y_W3")

plot_mds(test2) + 
  geom_text(aes(label = colnames(test2)), hjust = 1.2, vjust = 0.5)



```

TEXT.

```{r heatmapFunctions}
htmp <- function(x, k = 6, col_limit = 6, plot = TRUE) {
  
  df <- x
  
  # facultative kmeans clustering
  set.seed(1)
  df_kmeans <- kmeans(df, k)
  order <- data.frame(df) %>%
    cbind(., cluster = df_kmeans$cluster) %>%
    mutate(row = apply(.[, seq_len(ncol(.) - 1)], 1, function(x) max(x))) %>%
    group_by(cluster) %>%
    summarize(index = sum(row)/n()) %>%
    arrange(desc(index)) %>%
    pull(cluster) %>%
    match(seq_len(k), .)
  df_kmeans$cluster <- order[df_kmeans$cluster]
  
  clust_dist <- function(x) {
    dist <- cluster::daisy(x, metric = "gower")
    dist[is.na(dist)] <- max(dist, na.rm = TRUE)
    return(dist)
  }
  
  ht1 = ComplexHeatmap::Heatmap(df,
                col = circlize::colorRamp2(
                  seq(-col_limit, col_limit, (col_limit/5)),
                  rev(RColorBrewer::brewer.pal(11, "RdBu"))),
                split = df_kmeans$cluster,
                cluster_rows = TRUE,
                cluster_columns = TRUE,
                row_names_side = "left",
                column_names_side = "top",
                clustering_distance_rows = clust_dist,
                clustering_distance_columns = clust_dist,
                heatmap_legend_param = list(color_bar = "continuous",
                                            legend_direction = "horizontal",
                                            legend_width = unit(5, "cm"),
                                            title_position = "lefttop"))
  if(plot) {
    # Plot
    ComplexHeatmap::draw(ht1, heatmap_legend_side = "top")
  } else {
    # Return data.frame
    colnames(df) <- gsub(" ", "_", colnames(df))
    df <- df[, unlist(ComplexHeatmap::column_order(ht1))]
    df <- cbind(df, k = df_kmeans$cluster)
    df[unlist(ComplexHeatmap::row_order(ht1)),] %>%
      tibble::rownames_to_column(var = "gene_name") %>%
      as.data.frame() %>%
      mutate(order = row_number())
  }
}


htmp2 <- function(x, col_limit = 6, plot = TRUE) {
  df <- x
  
  
  
  clust_dist <- function(x) {
    dist <- cluster::daisy(x, metric = "gower")
    dist[is.na(dist)] <- max(dist, na.rm = TRUE)
    return(dist)
  }
  
  ht1 = ComplexHeatmap::Heatmap(df,
                                col = circlize::colorRamp2(
                                  seq(-col_limit, col_limit, (col_limit/5)),
                                  rev(RColorBrewer::brewer.pal(11, "RdBu"))),
                                cluster_rows = TRUE,
                                cluster_columns = TRUE,
                                row_names_side = "left",
                                column_names_side = "top",
                                clustering_distance_rows = clust_dist,
                                clustering_distance_columns = clust_dist,
                                heatmap_legend_param = list(color_bar = "continuous",
                                                            legend_direction = "horizontal",
                                                            legend_width = unit(5, "cm"),
                                                            title_position = "lefttop"), 
                                na_col = "green")
  if(plot) {
    # Plot
    ComplexHeatmap::draw(ht1, heatmap_legend_side = "top")
  } else {
    # Return data.frame
    colnames(df) <- gsub(" ", "_", colnames(df))
    df <- df[, unlist(ComplexHeatmap::column_order(ht1))]
    df[unlist(ComplexHeatmap::row_order(ht1)),] %>%
      tibble::rownames_to_column(var = "gene_name") %>%
      as.data.frame() %>%
      mutate(order = row_number())
  }
}

```


TEXT.

```{r combinedHeatmap}

test3 <- a9_res %>% 
  select(logFC, CGD_gene_name) %>% 
  full_join(., select(a1_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  full_join(., select(yeast_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  full_join(., select(biofilm_res, logFC, CGD_gene_name), by = "CGD_gene_name") %>% 
  rename(a9_lfc = logFC.x, 
         a1_lfc = logFC.y, 
         y_lfc = logFC.x.x, 
         b_lfc = logFC.y.y) %>% 
  select(CGD_gene_name, everything()) %>% 
  filter(CGD_gene_name %in% f1_overlap)

# select rows with max 1/4 NA
test4 <- test3 %>% 
  mutate(nna = apply(is.na(.), 1, sum)) %>% 
  filter(nna < 2) %>% 
  select(-nna) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()

# select rows with max 2/4 NA
test5 <- test3 %>% 
  mutate(nna = apply(is.na(.), 1, sum)) %>% 
  filter(nna < 3) %>% 
  select(-nna) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()

# select rows with max 3/4 NA
test6 <- test3 %>% 
  filter_at(.vars = vars(contains("lfc")), 
            any_vars(!is.na(.))) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()

# select rows with max 0/4 NA
test7 <- test3 %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  tidyr::drop_na() %>% 
  as.matrix()

# test heatmap with data with no missing values
htmp(test7, k = 3, plot = TRUE)

test8 <- htmp(as.data.frame(test7), plot = FALSE)

my_palette <- colorRampPalette(c("blue", "white", "red")) (n = 15)
breaks <- seq(-8, 8, length.out = 16)

gplots::heatmap.2(test7, trace = "none", na.color = "black", 
                  col = my_palette, breaks = breaks)

gplots::heatmap.2(test7, trace = "none", na.color = "black", 
                  col = my_palette, breaks = breaks, 
                  reorderfun = function(d,w) reorder(d, w, agglo.FUN = mean),
                  cexRow = 0.2,
                  cexCol = 0.8,
                  distfun = function(x) dist(x, method = "euclidean"),
                  hclustfun = function(x) hclust(x))

# get dataframe in order of heatmap
test10 <- test6[rev(test9$rowInd), test9$colInd]


# test heatmap with data with missing values

# cluster rows and columns
hr <- hclust(clust_dist(test6))

hc <- hclust(clust_dist(t(test6)))

# define row clusters
test11 <- cutree(hr, h = max(hr$height/1.5))

# get colour palette equal to number of clusters
clusterCols <- rainbow(length(unique(test11)))

# create vector of colours for side bar
myClusterSideBar <- clusterCols[test11]

# add cluster ID to data
test12 <- cbind(test6, clusterID = test11)

# examine data with cluster ID, ordered as in heatmap
test13 <- test12[hr$order,]

test14 <- test12 %>% 
  as.data.frame() %>% 
  select(clusterID)

test14$clusterID %<>% as.factor()

test9 <- gplots::heatmap.2(test6, trace = "none", na.color = "black", 
                  reorderfun = function(d,w) reorder(d, w, agglo.FUN = mean),
                  col = my_palette, breaks = breaks, distfun = function(x) clust_dist(x), 
                  hclustfun = function(x) hclust(x), 
                  RowSideColors = myClusterSideBar)

htmp2(test6, col_limit = 7, plot = TRUE)

# test pheatmap
pheatmap::pheatmap(test12, 
                   cluster_rows = hr, 
                   cluster_cols = hc, 
                   show_rownames = FALSE, 
                   annotation_row = test14, 
                   na_col = "black", 
                   cutree_rows = 5, 
                   scale = "none", 
                   color = my_palette, 
                   breaks = breaks, 
                   treeheight_row = 0)



```

TEXT.

```{r combinedHeatmapSig}
# test overlap of significant/EV exclusive proteins across all 4 datasets
pull_list <- function(x, my_cats) {
  result <- x %>% 
    filter(group %in% my_cats) %>% 
    pull(CGD_gene_name)
}

comp3 <- list("DAY286 Y" = pull_list(yeast_res, c("EV up", "EV ex", "WCL up")), 
              "DAY286 B" = pull_list(biofilm_res, c("EV up", "EV ex", "WCL up")), 
              "ATCC90028" = pull_list(a9_res, c("A9_EV up", "A9_EV ex", "A9_W up")), 
              "ATCC10231" = pull_list(a1_res, c("A1_EV up", "A1_EV ex", "A1_W up")))

f2 <- plot_venn(vlist = comp3, use_uniprot = FALSE, type = "plot")

f2 <- as_ggplot(f2) + 
  theme(plot.margin = unit(c(0,2,0,2), "lines"))

plot(f2)

f2_overlap <- plot_venn(vlist = comp3, use_uniprot = FALSE, type = "list") %>% 
  filter(..count.. == 55) %>% 
  pull(..values..) %>% 
  unlist()

test9 <- test3 %>% 
  filter(CGD_gene_name %in% f2_overlap) %>% 
  filter_at(.vars = vars(contains("lfc")), 
            any_vars(!is.na(.))) %>% 
  tibble::column_to_rownames(var = "CGD_gene_name") %>% 
  as.matrix()
  
gplots::heatmap.2(test9, trace = "none", na.color = "black", 
                  reorderfun = function(d,w) reorder(d, w, agglo.FUN = mean),
                  col = my_palette, breaks = breaks, distfun = function(x) clust_dist(x), 
                  hclustfun = function(x) hclust(x))

```



# EV marker protein selection

TEXT.

```{r markerComparison}
marker_comp <- list("yeast" = yeast_res %>% 
                      filter(group == "EV up" | group == "EV ex") %>% 
                      pull(CGD_gene_name), 
                    "biofilm" = biofilm_res %>% 
                      filter(group == "EV up" | group == "EV ex") %>% 
                      pull(CGD_gene_name), 
                    "ATCC10231" = a1_res %>% 
                      filter(group == "A1_EV up" | group == "A1_EV ex") %>% 
                      pull(CGD_gene_name), 
                    "ATCC90028" = a9_res %>% 
                      filter(group == "A9_EV up" | group == "A9_EV ex") %>% 
                      pull(CGD_gene_name))

upset(fromList(marker_comp), 
      point.size = 4.5, 
      line.size = 2, 
      mainbar.y.label = "\n\nIntersection protein number", 
      mainbar.y.max = 400, 
      sets.x.label = "Total protein number", 
      text.scale = c(2, 2, 1.2, 1.2, 1.7, 2), 
      order.by = "degree")
marker_comp_tab <- plot_venn(vlist = marker_comp, use_uniprot = FALSE, type = "list")

```

TEXT.

```{r markerExtract}
# marker_candidates <- marker_comp_tab %>% 
#   filter(..count.. > 0 & ..count.. < 40) %>% 
#   pull(..values..) %>% 
#   set_names(c("both ex", "yev up bev ex", "yev ex bev up", "both up"))

marker_candidates <- marker_comp_tab %>% 
  filter(apply(.[, 1:4], 1, sum) == 4) %>% 
  pull(..values..) %>% 
  unlist() %>% 
  as.data.frame(stringsAsFactors = FALSE) %>% 
  rename(Gene = 1)

marker_longlist <- marker_candidates %>% 
  mutate(Protein = match_id(Gene, uniprot, "CGD_gene_name", "Protein_name"),
         DAY.Y = match_id(Gene, yeast_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         DAY.B = match_id(Gene, biofilm_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         A1 = match_id(Gene, a1_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         A9 = match_id(Gene, a9_res, "CGD_gene_name", "logFC", str_split = FALSE), 
         TM = match_id(Gene, uniprot, "CGD_gene_name", "Transmembrane"), 
         SP = match_id(Gene, uniprot, "CGD_gene_name", "Signal_peptide")) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ signif(as.numeric(.), digits = 3))) %>% 
  mutate_at(.vars = vars(DAY.Y, DAY.B, A1, A9), 
            .funs = list(~ case_when(is.na(.) == TRUE ~ "ex", 
                                     TRUE ~ as.character(.)))) %>% 
  mutate(TM = stringr::str_count(TM, "Helical"), 
         SP = case_when(grepl("SIGNAL", SP) ~ "Y", 
                        TRUE ~ ""), 
         TM = case_when(TM == 0 ~ "", 
                        TRUE ~ as.character(TM))) %>% 
  arrange(Gene)

marker_longlist[3, 7] <- "12;12"

protein_desc <- c("1,3-beta-glucanosyltransferase", 
                  "Rho family GTPase", 
                  "Multidrug transporter of ABC superfamily", 
                  "Major chitin synthase of yeast and hyphae", 
                  "GPI-anchored cell wall transglycosylase", 
                  "GPI-anchored cell wall protein", 
                  "Predicted P-type ATPase sodium pump", 
                  "ER oxidoreductin", 
                  "Long-chain fatty acid-CoA ligase", 
                  "Multicopper feroxidase", 
                  "High-affinity S-adenosylmethionine permease", 
                  "Surface protein similar to glycerol-3-phosphate dehydrogenase", 
                  "1,3-beta-glucan synthase", 
                  "High-affinity MFS glucose transporter", 
                  "Putative high-affinity MFS glucose transporter", 
                  "Putative mitochondrial phosphate transporter", 
                  "Glycolipid 2-alpha-mannosyltransferase", 
                  "Cell surface mannoprotein", 
                  "Mucin family adhesin-like protein", 
                  "Sphingolipid C9-methyltransferase", 
                  "S. cerevisiae ortholog is POM33, transmembrane nucleoporin", 
                  "S. cerevisiae ortholog is RTN1, reticulon protein", 
                  "Hexadecenal dehydrogenase", 
                  "S. cerevisiae ortholog is PUN1, plasma membrane protein", 
                  "1,3-beta-glucanosyltransferase", 
                  "GPI-anchored cell surface protein of unknown function", 
                  "Putative ion transporter", 
                  "Cell surface glycosidase", 
                  "Glycosidase", 
                  "Phospholipase B", 
                  "Plasma membrane ATPase", 
                  "Mitochondrial outer membrane porin", 
                  "G-protein of RAC subfamily", 
                  "Rho family GTPase", 
                  "Rho family GTPase", 
                  "Secreted aspartyl protease", 
                  "Rab family GTPase", 
                  "Protein required for normal cell wall, plasma membrane", 
                  "Protein involved in vacuolar inheritance", 
                  "S. cerevisiae ortholog is YCK2, casein kinase", 
                  "Palmitoyltransferase, putative vacuolar SNARE complex protein", 
                  "Rab family GTPase", 
                  "Putative vacuolar cation channel")
marker_longlist <- marker_longlist %>% 
  mutate(Protein = protein_desc)

                         
knitr::kable(marker_longlist)

```


