---
title: "Vignette title"
author: 
- name: Charlotte Dawson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Mark Bleackley
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Donovan Garcia Ceron
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
- name: Marilyn Anderson
  affiliation: Department of Biochemistry and Genetics, 
               La Trobe Institute of Molecular Science, 
               La Trobe University, Australia
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
  BiocStyle::html_document:
    toc: true
    df_print: kable
package: candidaev
abstract: | 
  This is the abstract.
vignette: > 
  %\VignetteIndexEntry{Vignette title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r knitrOpts, include=FALSE}
# knit options
knitr::opts_knit$set(progress = TRUE, 
                     verbose = TRUE)

# chunk options
knitr::opts_chunk$set(collapse = FALSE,
                      warning = TRUE,
                      message = TRUE,
                      echo = FALSE,
                      error = TRUE, 
                      comment = "#>")

# check for installation of packages required to knit this vignette
req_pkgs <- c("BiocStyle", "ggpubr", "stringi", "DT")

check_pkgs <- function(x) {
  if(!requireNamespace(x, quietly = TRUE)) {
    stop(paste0("The package ",
                paste0(x),
                " is required to knit this document. 
                Please install it."))
  }
}

lapply(req_pkgs, check_pkgs)
```

# Preface

## Introduction

This vignette outlines the method used to analyse the label-free quantitative 
LC-MS/MS data obtained for _C. albicans_ (strains ATCC10231 and ATCC90028) 
extracellular vesicles (EVs) and whole cell lysates (WCL) by Dawson et 
al. (2019). The tools provided in this package, `r Githubpkg("csdaw/candidaev")`
, allows the step-by-step reproduction of the results presented in the paper. 
The manuscript in its submitted form and the `.Rmarkdown` file used to 
generate it can found 
[here](https://github.com/csdaw/candidaev/tree/master/manuscript).

The analysis workflow used in this vignette is derived from the excellent 
**Bioconductor** package `r Biocpkg("DEP")`[^1]. Furthermore, some of the 
plotting functions available in `r Biocpkg("DEP")` have been modified for use 
in this package, `r Githubpkg("csdaw/candidaev")`. 

[^1]: Zhang, X., Smits, A. H., van Tilburg, G. B. A., Ovaa, H., Huber, W., & 
Vermeulen, M. (2018). Proteome-wide identification of ubiquitin interactions 
using UbIA-MS. _Nature Protocols, 13_(3), 530-550. 
[doi:10.1038/nprot.2017.147](https://doi.org/10.1038/nprot.2017.147)

## Experimental design

Extracellular vesicles (EVs) were isolated using differential 
ultracentrifugation from _C. albicans_ liquid cultures 
from two clinical isolate strains; ATCC10231 (n = 3) and ATCC90028 (n = 3). 
Additionally, cells from these liquid cultures were separated and lysed to 
generate whole cell lysates (WCL). Each EV biological replicate was paired 
with a WCL replicate as they were derived from the same liquid culture.

Samples analysed in this vignette:

* ATCC10231 EV1
* ATCC10231 EV2
* ATCC10231 EV3
* ATCC10231 WCL1 (W1)
* ATCC10231 WCL2 (W2)
* ATCC10231 WCL3 (W3)

and

* ATCC90028 EV1
* ATCC90028 EV2
* ATCC90028 EV3
* ATCC90028 WCL1 (W1)
* ATCC90028 WCL2 (W2)
* ATCC90028 WCL3 (W3)

These samples were electrophoresed and the SDS-PAGE gel slices were 
reduced, alkylated, and digested with trypsin. The resulting peptides were 
extracted with acetonitrile, analysed by nano-LC-ESI-MS/MS, identified using 
MaxQuant, and quantified via the MaxLFQ algorithm in MaxQuant. 
The `proteinGroups.txt` file output was used for subsequent analyses.

## Data availability

The raw data was searched against the _C. albicans_ (SC5314) UniProt 
reference proteome (UP000000559) using MaxQuant version 1.6.0.16.  The 
`proteinGroups.txt` file analysed in this vignette 
can be easily accessed 
[here](https://github.com/csdaw/candidaev/tree/master/data-raw/lcms). 
It is also installed along with the 
`r Githubpkg("csdaw/candidaev")` package and can be loaded in R with 

```
data(atcc)
```

The LC-MS/MS raw data, peak data, and results files have been 
deposited in the ProteomeXchange Consortium database via the PRIDE partner 
repository with the data set identifier y and DOI x. 

# Data analysis
    
## Setup

The packages required for the analyses are loaded and a specific 
seed is set for the steps requiring random number generation (imputation 
and clustering).

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
# load packages
library(candidaev)
library(dplyr)
library(ggplot2)

# set seed for imputation, kmeans, MDS plot
set.seed(1)
```

To reproduce the results exactly as they are in Dawson et al. (2019), the 
following code block is run to perform a specific number of draws from 
a random distribution before performing the analysis of the `atcc` data. 
Otherwise, the results will be extremely similar but not identical to Dawson 
et al. (2019).

```{r randomDraws, echo=TRUE}
# for results to be reproducible in seperate documents
# need to use set.seed AND need to perform same number of 
# 'random' draws in the same order as manuscript.Rmd

# DAY286 yeast
yeast_lfq <- yeast %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., yeast_exp)

yeast_lfq2 <- yeast_lfq[, !colnames(yeast_lfq) %in% c("EV_1", "WCL_1")]

yeast_filt2 <- filter_na2(yeast_lfq2, logic = "or", op = "<=", 
                          pat1 = "EV", val1 = 1, 
                          pat2 = "W", val2 = 1)

yeast_norm2 <- limma::normalizeCyclicLoess(yeast_filt2)

yeast_excl <- filter_na2(yeast_norm2, logic = "or", op = "==", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

yeast_both <- filter_na2(yeast_norm2, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 2, 
                         pat2 = "W", val2 = 2)

yeast_imp <- impute_QRILC(yeast_both) # first set of random draws

# DAY286 biofilm
biofilm_lfq <- biofilm %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., biofilm_exp)

biofilm_filt <- filter_na2(biofilm_lfq, logic = "or", op = "<=", 
                           pat1 = "EV", val1 = 1, 
                           pat2 = "W", val2 = 1)

biofilm_norm <- limma::normalizeCyclicLoess(biofilm_filt)

biofilm_excl <- filter_na2(biofilm_norm, logic = "or", op = ">=", 
                         pat1 = "EV", val1 = 4, 
                         pat2 = "W", val2 = 4)

biofilm_both <- filter_na2(biofilm_norm, logic = "and", op = "<=", 
                         pat1 = "EV", val1 = 3, 
                         pat2 = "W", val2 = 3)

biofilm_imp <- impute_QRILC(biofilm_both) # second set of random draws
```

## Exploring the `atcc` data set

As above, the _C. albicans_ ATCC LC-MS/MS data set is provided as a 
data.frame called `atcc` in this package. 
It has `r nrow(atcc)` rows each of which corresponds to a single protein 
group[^2], and `r ncol(atcc)` columns. 
A key describing most of these columns can be found in the 
[MaxQuant documentation](http://www.coxdocs.org/doku.php?id=maxquant:table:proteingrouptable). 
The `LFQ.intensity` columns hold the protein quantification data that is 
used for the following analyses.

[^2]: Each protein group comprises the group of proteins that could be 
reconstructed from a set of peptides by MaxQuant. In most cases this will be 
a single protein but sometimes there will be two or more proteins that 
could not be distinguished by the set of peptides.

```{r atccColumns, echo=TRUE}
colnames(atcc)
```

`atcc_exp` is another data.frame provided in this package. It 
describes the experimental design underlying the `atcc` data set. 
The primary function `atcc_exp` is to provide info for labelling 
and grouping data in some of the plotting functions from 
the **Bioconductor** package `r Biocpkg("DEP")`, which have been 
modified for use in this package. `atcc_exp` supplies sample 
information (biological replicate, strain) for each 
`LFQ.intensity` column in the `atcc` data.frame.

It has the following structure. Notice that each row in the `label` 
column of `atcc_exp` is exactly the same as the names of the 
`LFQ.intensity` columns of `atcc`.

```{r atccexpTable}
knitr::kable(atcc_exp, 
             caption = "Experimental design for this vignette.")
```

## Data preparation

First, the `atcc` proteinGroups data.frame is filtered to remove reverse 
proteins, contaminant proteins, and proteins identified by less than 2 unique 
peptides.

```{r atccInit, echo=TRUE}
# filter out reverse, contaminant proteins, proteins with <2 unique peptides
# extract LFQ intensity columns and UniProt accessions 
# log2 transform LFQ intensities
atcc_lfq <- atcc %>% 
  filter(Reverse != "+", 
         Potential.contaminant != "+", 
         Unique.peptides >= 2) %>% 
  convert_lfq(., atcc_exp)
```

Then the data.frame is converted into a compact format using the `convert_lfq` 
function which performs the following:

1. Ensures the names of the `LFQ.intensity` columns in `atcc` exactly match 
   those in the `label` column of the experimental design, `atcc_exp`.
   
2. Returns a matrix containing only: the UniProt accession(s) and LFQ 
   intensities of each protein across the 12 samples. 
   
3. Log<sub>2</sub> transforms the LFQ intensities.

--------------------------------------------------------------------------------

The resulting matrix `atcc_lfq` still has `r nrow(atcc_lfq)` rows but only 
`r ncol(atcc_lfq)` columns, one for each LC-MS/MS sample. The total number of 
proteins quantified (i.e. have a non-`NA` LFQ intensity) in each sample can 
be explored using:
```{r, echo=TRUE, eval=FALSE}
# explore quantification across all 12 samples
plot_frequency2(atcc_lfq)

# explore protein quantification in individual samples
plot_numbers2(atcc_lfq, atcc_exp)
```
The proteins in this data set 
are not quantified in every biological replicate of every strain. 
If fact in Figure \@ref(fig:atccInit2)A shows that most of the proteins are 
only quantified in a single sample. Figure \@ref(fig:atccInit2)B shows the 
total number of proteins quantified in each sample.

```{r atccInit2, fig.cap=atccInit2_cap, fig.wide=TRUE}
freq1 <- plot_frequency2(atcc_lfq) + 
  scale_y_continuous(limits = c(0,600), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb1 <- plot_numbers2(atcc_lfq, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 2250), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq1, numb1,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccInit2_cap <- "Protein quantification distributions. (A) Cumulative 
number of proteins quantified in 1-12 samples. (B) Total number of proteins 
quantified in each biological replicate sample."
```

The percentage of non-valid (`NA`) values and other useful statistics for 
each sample is shown using:
```{r, echo=TRUE, eval=FALSE}
# generate summary table from LFQ data
sum_table(atcc_lfq)
```
Table \@ref(tab:atccInit3) shows that the ATCC10231 samples have higher 
percentages of missing values than the ATCC90028 samples.

```{r atccInit3}
knitr::kable(sum_table(atcc_lfq), 
             caption = "Descriptive statistics for each LC-MS/MS sample.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

## Protein filtering (replicate quantification)

Prior to normalisation and imputation, proteins with too many missing values 
across the 12 samples are removed. Only those with at least 2/3 valid values 
in 1 of the 4 conditions are retained.

This filtration is performed using `filter_na4`.

```{r atccFilt, echo=TRUE}
# filter for proteins quantified in min 2/3 reps of: 
# A1 EV or A1 WCL or A9 EV or A9 WCL
atcc_filt <- filter_na4(atcc_lfq, 
                        logic = "or", 
                        op = "<=", 
                        pat1 = "A10231_EV", val1 = 1, 
                        pat2 = "A10231_W", val2 = 1, 
                        pat3 = "A90028_EV", val3 = 1, 
                        pat4 = "A90028_W", val4 = 1)
```

The initial `r nrow(atcc_lfq)` proteins has been reduced to 
`r nrow(atcc_filt)`. Now the majority of proteins are quantified in all 12 
samples. The overall pattern of proteins in each sample remains similar 
though.

```{r atccFilt2, fig.cap=atccFilt2_cap, fig.wide=TRUE}
freq2 <- plot_frequency2(atcc_filt) + 
  scale_y_continuous(limits = c(0,400), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(plot.title = element_text(size = 16))

numb2 <- plot_numbers2(atcc_filt, atcc_exp) + 
  theme(plot.title = element_text(size = 16),
        axis.text.x = element_text(angle = 0), 
        legend.position = "right", 
        legend.text = element_text(size = 12), 
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = -15, unit = "pt")) +  
  scale_y_continuous(limits = c(0, 1750), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  labs(title = "Proteins per biological replicate") + 
  xlab("Biological replicate") + 
  guides(fill = guide_legend(nrow = 4, byrow = TRUE))

ggpubr::ggarrange(freq2, numb2,
                  labels = c("A", "B"), 
                  ncol = 2, 
                  nrow = 1, 
                  font.label = list(size = 24, color = "black"), 
                  widths = c(1, 1.4), 
                  vjust = 1)

atccFilt2_cap <- "Protein quantification distributions after filtration. 
                  (A) Cumulative number of proteins quantified in 1-12 samples. 
                  (B) Total number of proteins quantified in each biological 
                  replicate sample."
```

A multidimensional scaling plot can be drawn via:
```{r, echo=TRUE, eval=FALSE}
# need labels for the MDS plot
mds_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

# generate MDS plot
plot_mds(atcc_filt, mat_labels = mds_labels, 
         shape_size = 4)
```
It shows that the WCL samples from both strains cluster closer together than 
the EV samples do to each other, indicating they have a smaller 
log<sub>2</sub> fold change between them.

```{r atccFilt3, fig.cap=atccFilt3_cap, fig.small=TRUE}
mds1_labels <- c(rep("EV", 3), 
                 rep("WCL", 3), 
                 rep("EV", 3), 
                 rep("WCL", 3))

plot_mds(atcc_filt, mat_labels = mds1_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-1.5, 0.75), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-4, 2), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccFilt3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
                  biological replicate sample with the first 2 dimensions 
                  plotted. Pairwise distance between samples approximately 
                  indicates the log2 fold change between samples."
```

## LFQ intensity normalisation

Next, the LFQ intensity data is normalised using `r Biocpkg("limma")`.

```{r atccNorm, echo=TRUE}
# normalise LFQ intensities
atcc_norm <- limma::normalizeCyclicLoess(atcc_filt)
```

The effect of the normalisation on the distribution of LFQ intensities for 
each sample is visualised using: 
```{r, echo=TRUE, eval=FALSE}
# explore effect of normalisation on intensity distributions
plot_normalization2(atcc_exp, atcc_filt, atcc_norm)
```

```{r atccNorm2, fig.cap=atccNorm2_cap, fig.height=7}
plot_normalization2(atcc_exp, 
                    facet_labels = c(atcc_filt = "Before normalisation", 
                                     atcc_norm = "After normalisation"), 
                    atcc_filt, atcc_norm) + 
  scale_x_discrete(labels = c(rep(1:3, 4))) + 
  xlab("Biological replicate") + 
  theme(plot.margin = margin(t = 0, l = 1.5, r = 1.5, b = 0, unit = "inches"))
  

atccNorm2_cap <- "Distribution of protein LFQ intensities for each sample. Shown
                  before and after normalisation."
```

The MDS plot now shows that the first dimension (which is the leading factor 
causing the LFQ intensities differences between samples) separates the 
samples according to the primary condition of interest; EV versus WCL. Then 
the second dimension separates the samples according to the strain.

```{r atccNorm3, fig.cap=atccNorm3_cap, fig.small=TRUE}
mds2_labels <- c(rep("EV", 3), 
                rep("WCL", 3), 
                rep("EV", 3), 
                rep("WCL", 3))

plot_mds(atcc_norm, mat_labels = mds2_labels, 
         shape_size = 4) + 
  scale_y_continuous(limits = c(-0.8, 0.8), 
                     expand = expand_scale(mult = c(0, 0))) + 
  scale_x_continuous(limits = c(-1, 1), 
                     expand = expand_scale(mult = c(0, 0))) + 
  theme(legend.position = "bottom", 
        legend.title = element_blank()) + 
  scale_fill_manual(values = c("orange", "red")) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

atccNorm3_cap <- "Multidimensional scaling (MDS) plot. Shows each LC-MS/MS
                  biological replicate sample after normalisation, with the 
                  first 2 dimensions plotted. Pairwise distance between samples 
                  approximately 
                  indicates the log2 fold change between samples."
```


## ATCC strain protein comparison

Lists of proteins quantified in at least 1/3 biological replicates of each 
condition are generated using:

```{r atccVennData, echo=TRUE}
# filter for proteins identified in min 1/3 reps of 10231 EV
atcc1_ev <- filter_na(atcc_norm, 
                      op = "<=", 
                      pat = "A10231_EV", 
                      val = 2)

# filter for proteins identified in min 1/3 reps of 10231 WCL
atcc1_w <- filter_na(atcc_norm, 
                     op = "<=", 
                     pat = "A10231_W", 
                     val = 2)

# filter for proteins identified in min 1/3 reps of 90028 EV
atcc9_ev <- filter_na(atcc_norm, 
                      op = "<=", 
                      pat = "A90028_EV", 
                      val = 2)

# filter for proteins identified in min 1/3 reps of 90028 WCL
atcc9_w <- filter_na(atcc_norm, 
                     op = "<=", 
                     pat = "A90028_W", 
                     val = 2)
```

These are then compared using a Venn diagram.
```{r, echo=TRUE, eval=FALSE}
# define a comparison list for a Venn diagram
venn_comp <- list("A10231_EV" = rownames(atcc1_ev), 
                  "A10231_WCL" = rownames(atcc1_w), 
                  "A90028_EV" = rownames(atcc9_ev), 
                  "A90028_WCL" = rownames(atcc9_w))
                  
# plot the Venn diagram
venn <- plot_venn(venn_comp, 
                  type = "plot")
                  
grid::grid.draw(venn)
```
Of the `r nrow(atcc_norm)` proteins quantified in at least 2/3 replicates of 
1 out of 4 conditions, 641 (41.7%) are quantified in all 4 conditions. 

```{r atccVenn, fig.cap=venn_cap}
# define comparison list for Venn diagram
venn1_comp <- list("A10231_EV" = rownames(atcc1_ev), 
                   "A10231_WCL" = rownames(atcc1_w), 
                   "A90028_EV" = rownames(atcc9_ev), 
                   "A90028_WCL" = rownames(atcc9_w))

# define ggplot2 default colour palette function
gg_colour <- function(n) {
  hues <- seq(15, 375, length = n + 1)
  grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

# plot Venn diagram
venn1 <- plot_venn(venn1_comp, 
                   use_uniprot = FALSE, 
                   type = "plot", 
                   fontfamily = "sans", 
                   cat.fontfamily = "sans", 
                   cex = 1.9, 
                   cat.cex = 1.2, 
                   fill = gg_colour(4), 
                   alpha = c(rep(0.4, 4)))

# draw Venn diagram
grid::grid.draw(venn1)

venn_cap <- "Venn diagram of proteins quantified in each condition. 
             Proteins in this plot are quantified in at least 2/3 replicates 
             of at least condition."
```

Next, the most abundant proteins that are only detected in ATCC10231 EVs and 
not in ATCC10231 WCL can be identified.

```{r atcc1Top10Data, echo=TRUE}
# get top 10 most abundant protein exclusive to 10231 EVs
# in descending order of abundance
atcc1_top10 <- atcc1_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A10231_W", val = 3) %>% 
  select(id, contains("A10231_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A10231_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)
```

```{r atcc1Top10}
knitr::kable(atcc1_top10, 
             caption = "Top 10 most abundant ATCC10231 EV proteins. They are 
                        not detected in ATCC10231 WCL.", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

This is repeated for ATCC90028. The proteins MSB2, PLB4.5, orf19.6119, and 
orf19.1054 are highly abundant and exclusive to EVs from both strains.

```{r atcc9Top10Data, echo=TRUE}
atcc9_top10 <- atcc9_ev %>% 
  tibble::as_tibble(rownames = "id") %>% 
  filter_na(., op = "==", pat = "A90028_W", val = 3) %>% 
  select(id, contains("A90028_EV")) %>% 
  mutate(mean = rowMeans(select(., contains("A90028_EV")), na.rm = TRUE)) %>% 
  top_n(n = 10, wt = mean) %>% 
  arrange(desc(mean)) %>% 
  match_id_multi(., "id", uniprot, "UP_accession", 
                 new = c("CGD_gene_name", 
                         "CGD_description")) %>% 
  select(CGD_gene_name, CGD_description, everything(), -id)
```

```{r atcc9Top10}
knitr::kable(atcc9_top10, 
             caption = "Top 10 most abundant ATCC90028 EV proteins. They are 
                        not detected in ATCC90028 WCL.", 
             col.names = c("Name", "Function", "EV1 LFQ", 
                           "EV2 LFQ", "EV3 LFQ", "Mean LFQ"), 
             digits = 1)
```

## Imputation of missing values

Missing values in the data will be imputed prior to the 
differential abundance analysis. Before imputation the percentage of missing 
values in each sample is explored again with `sum_table(atcc_norm)`.

```{r atccSum}
# explore percentage missing values in each sample
knitr::kable(sum_table(atcc_norm), 
             caption = "Descriptive statistics for each LC-MS/MS sample. After 
                        normalisation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

The percentage of missing values ranges from 25.4% up to 64.7% which is 
quite high, typical of label-free quantitative proteomics data[^3]. The 
pattern of missing values across the data is visualised using:

[^3]: Lazar, C., Gatto, L., Ferro, M., Bruley, C., Burger, T. (2016). 
Accounting for the Multiple Natures of Missing Values in Label-Free 
Quantitative Proteomics Data Sets to Compare Imputation Strategies. 
_Journal of Proteome Research, 15_(4), 1116-1125. 
[doi:10.1021/acs.jproteome.5b00981](https://doi.org/10.1021/acs.jproteome.5b00981)

```{r, echo=TRUE, eval=FALSE}
# visualise missing values using a heatmap
plot_missval2(atcc_norm)
```

```{r atccMissVal, fig.cap=missval_cap, fig.height=8}
plot_missval2(atcc_norm)

missval_cap <- "Pattern of missing LFQ intensity values."
```

There are large chunks of data missing in either all of 
the WCL samples or all of the EV samples. To minimise the percentage of 
missing values in each sample, these proteins are removed prior to 
imputation and hence are not imputed.
```{r, echo=TRUE}
# should not impute with so many missing values
# filter for exclusive to 10231 EV or WCL or 90028 EV or WCL
# these will not be imputed
atcc_excl <- filter_na4(atcc_norm, 
                        logic = "or", 
                        op = "==", 
                        pat1 = "A10231_EV", val1 = 3, 
                        pat2 = "A10231_W", val2 = 3, 
                        pat3 = "A90028_EV", val3 = 3, 
                        pat4 = "A90028_W", val4 = 3)
```

Only proteins quantified in at least 1/3 replicates from all 4 conditions 
are retained for imputation.
```{r, echo=TRUE}
# filter for proteins with min 1 valid value in all 4 sample types
atcc_both <- filter_na4(atcc_norm, 
                        logic = "and", 
                        op = "<=", 
                        pat1 = "A10231_EV", val1 = 2, 
                        pat2 = "A10231_W", val2 = 2, 
                        pat3 = "A90028_EV", val3 = 2, 
                        pat4 = "A90028_W", val4 = 2)
```

`r nrow(atcc_excl)` proteins which are exclusive to either ATCC10231 EV, 
ATCC10231 WCL, ATCC90028 EV, or ATCC90028 WCL are removed (`atcc_excl`). 
Conversely, `r nrow(atcc_both)` proteins are kept to have missing values 
imputed (`atcc_both`). The percentage of missing values across each sample 
in `atcc_both` now ranges from 1.4% to 29.3%. 

```{r atccSum2}
knitr::kable(sum_table(atcc_both), 
             caption = "Descriptive statistics for each LC-MS/MS sample. Prior 
                        to imputation.", 
             col.names = c("Sample", "Mean LFQ intensity", 
                           "Median LFQ intensity", "SD", "CV", 
                           "Min LFQ intensity", "Max LFQ intensity", 
                           "Range", "Number of proteins", "Number of NA", 
                           "Percent NA"), 
             digits = 1)
```

The pattern of missing values in `atcc_both` seems to be biased to certain 
samples, especially ATCC10231 EV replicate 1. Therefore, these proteins may be 
missing not at random (MNAR). 

```{r atccMissVal2, fig.cap=missval2_cap , fig.height=8}
plot_missval2(atcc_both)

missval2_cap <- "Pattern of missing LFQ intensity values."
```

The LFQ intensity distributions and cumulative fraction of proteins with and 
without missing values can be plotted with: 

```{r, echo=TRUE, eval=FALSE}
# detect intensity differences for proteins with missing values
plot_detect2(atcc_both)
```

```{r atccSum3, fig.cap=detect_cap, fig.wide=TRUE}
plot_detect2(atcc_both)

detect_cap <- "LFQ intensities of proteins with and without missing values."
```

These plots show that missing values are biased to proteins with lower 
average intensities, and are likely MNAR. Hence, a left-censored imputation 
method is used for imputation of missing values. 

```{r, echo=TRUE, eval=FALSE}
# impute missing values with QRILC method
atcc_imp <- impute_QRILC(atcc_both)
```

The effect of imputation on the distribution of protein intensities is 
visualised with:

```{r, echo=TRUE, eval=FALSE}
plot_imputation2(atcc_exp, 
                 facet_labels = c(atcc_both = "Before imputation", 
                                  atcc_imp = "After imputation"), 
                 atcc_both, 
                 atcc_imp)
```

```{r atccImpute, fig.cap=imp_cap, fig.wide=TRUE}
# proteins with missing values tend to have lower intensity
# therefore proteins are MNAR, close to detection limit

# use left censored imputation method
atcc_imp <- impute_QRILC(atcc_both)

plot_imputation2(atcc_exp, facet_labels = c(atcc_both = "Before imputation", 
                                            atcc_imp = "After imputation"),  
                 atcc_both, atcc_imp)

imp_cap <- "LFQ intensity distribution before and after imputation."
```

The changes to the distributions are minimal, but most noticable for ATCC10231 
EV. ATCC10231 samples EV1 and EV2 had the most missing values to impute.

## Differential abundance analysis with _limma_

Prior to differential abundance analysis, the imputed and non-imputed proteins 
are recombined in the same matrix.

```{r atccDE, echo=TRUE}
# combine matrices
atcc_de <- rbind(atcc_excl, atcc_imp)

# shorten column names
colnames(atcc_de) <- stringi::stri_replace_all_regex(colnames(atcc_de), 
                                                     c("A10231_", "A90028_"), 
                                                     c("A1_", "A9_"), 
                                                     vectorize_all = FALSE)
```

A design matrix is constructed for this proteomics experiment. This is 
required for the linear model fit function (`lmFit`) from 
`r Biocpkg("limma")` which is called inside the `limma_eBayes` function in 
this package. See the _limma_ User Guide section 9.2
[here](https://bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf) 
for more information about constructing design matrices.

```{r atccDesign, echo=TRUE}
# see limma user guide section 9.2 for more info about DE
# create design matrix
atcc_samp <- data.frame(T = (rep(c("A1_EV", "A1_WCL", 
                                   "A9_EV", "A9_WCL"), each = 3)))

atcc_design <- stats::model.matrix(~ 0 + T, data = atcc_samp)
colnames(atcc_design) <- c("A1_EV", "A1_W", "A9_EV", "A9_W")
```


```{r atccDE2}
knitr::kable(atcc_design, 
             caption = "Design matrix for comparing EV and WCL samples.")
```

The comparisons between samples that one is interested in are defined in a 
character vector. These must be two column names from the design matrix 
separated by ` - `.

```{r atccDE3, echo=TRUE}
# specify comparisons of interest
atcc_contrasts <- c("A1_EV - A1_W", "A9_EV - A9_W")
```

Finally, the differential abundance analysis is performed using the 
`limma_eBayes` function from this package which calls `eBayes` from 
`r Biocpkg("limma")`. 

To perform the analysis, the following objects are provided:
* a numeric matrix of log<sub>2</sub> LFQ intensity data (`atcc_de`).
* a numeric design matrix (`atcc_design`).
* a character vector with the contrasts of interest (`atcc_contrasts`).

The results from `limma_eBayes` are extracted using `get_results` 
which allows the adjusted p-value cutoff and 
log<sub>2</sub> fold change cutoff for significance to be specified. To get the 
overall differences for all the samples included in the design matrix, 
`type = "overall"` is used.

```{r atccDE4, echo=TRUE, warning=FALSE}
# make all pair-wise comparisons for specified contrasts
# and perform limma::eBayes()
atcc_efit <- limma_eBayes(atcc_de, atcc_design, atcc_contrasts)

# extract overall results
atcc_overall <- get_results(efit = atcc_efit, mat = atcc_de, 
                            p_val = 0.01, lfc = 0, type = "overall")
```

Alternatively, to obtain the log<sub>2</sub> fold changes and adjusted p-values 
for each individual comparison specified then `type = "individual"` is used. 
This outputs a list of data.frames, one for each contrast. They can be accessed 
by subsetting the resulting list.

```{r atccDE5, echo=TRUE}
# extract results for individual comparisons defined in atcc_contrasts
atcc_ind <- get_results(efit = atcc_efit, mat = atcc_de, 
                        p_val = 0.01, lfc = 0, type = "individual")

a1_res <- get_results(efit = atcc_efit, 
                      mat = atcc_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[1]]

a9_res <- get_results(efit = atcc_efit, 
                      mat = atcc_de, 
                      p_val = 0.01, 
                      lfc = 0, 
                      type = "individual")[[2]]
```

# Results

## ATCC10231

Differential abundance comparison of proteins in ATCC10231 EVs versus WCL.

```{r a1ResData, include=FALSE}
a1_res_short <- a1_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a1Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a1_res_short, 
              caption = "This is a table caption. Note that adjusted p-values 
              have been shortened to three significant figures for ease of 
              display.", 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```

## ATCC90028

Differential abundance comparison of proteins in ATCC90028 EVs versus WCL.

```{r a9ResData, include=FALSE}
a9_res_short <- a9_res %>% 
  select(CGD_gene_name, Protein_name, logFC, 
         contains("_mean"), adj.P.Val, group) %>% 
  mutate_at(.vars = vars(logFC, contains("_mean")), 
            .funs = list(~round(., digits = 2))) %>% 
  mutate(adj.P.Val = signif(adj.P.Val, digits = 3), 
         group = as.factor(group))
```

```{r a9Res}
js1 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 40 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 40) + 
              '...</span>' : data;",
              "}")

js2 <- DT::JS("function(data, type, row, meta) {",
              "return type === 'display' && data.length > 12 ?",
              "'<span title=\"' + data + '\">' + data.substr(0, 12) + 
              '...</span>' : data;",
              "}")

DT::datatable(a9_res_short, 
              rownames = FALSE, 
              colnames = c("Gene" = "CGD_gene_name", 
                           "Protein" = "Protein_name", 
                           "p.adj" = "adj.P.Val"), 
              filter = list(position = "bottom", clear = FALSE, plain = TRUE), 
              class = "display compact", 
              options = list(
                autowidth = TRUE, 
                columnDefs = list(list(width = "40%", targets = 1), 
                                  list(width = "10%", targets = c(0, 2:6)), 
                                  list(targets = 1, 
                                       render = js1), 
                                  list(targets = 0, 
                                       render = js2)
                )
              )
)
```

## Volcano plot

The results tables are used to construct volcano plots for ATCC10231 and 
ATCC9002. The `plot_volcano` function requires a data.frame input (`a1_res`) 
and specification of the column names that contain the data to be plotted 
(`adj.P.Val` and `logFC`). The `group` column in `a1_res` is used to separate 
the data into three groups that have different colours.

```{r a1Volcano, echo=TRUE}
a1_vol <- plot_volcano(a1_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 14), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 8))
```

```{r a9Volcano, echo=TRUE}
a9_vol <- plot_volcano(a9_res, 
                       p_val = adj.P.Val, 
                       log2fc = logFC, 
                       group = group, 
                       use_labels = TRUE, 
                       label_fun = ifelse(logFC >= 6, CGD_gene_name, ""), 
                       point_size = 2, 
                       label_size = 4, 
                       legend_params = c("right", 14, 12), 
                       axis_params = c("black", 16, 14), 
                       x_lim = c(-10, 12), 
                       y_lim = c(0, 8))
```

```{r atccVolcanoData, include=FALSE}
a1_volcano <- a1_vol + 
  scale_colour_manual(values = c("#D55E00",
                                 "#0072B2", 
                                 "#999999"), 
                      labels = c("EV enriched", 
                                 "WCL enriched", 
                                 "Not significant")) + 
  theme(legend.title = element_blank())

a9_volcano <- a9_vol + 
  scale_colour_manual(values = c("#D55E00",
                                 "#0072B2", 
                                 "#999999"), 
                      labels = c("EV enriched", 
                                 "WCL enriched", 
                                 "Not significant")) + 
  theme(legend.title = element_blank())
```

```{r atccVolcano, fig.cap=vol_cap, fig.wide=TRUE}
ggpubr::ggarrange(a1_volcano, a9_volcano,
                  labels = c("A", "B"),
                  ncol = 2,
                  nrow = 1,
                  align = "hv",
                  common.legend = TRUE,
                  legend = "bottom",
                  hjust = 0,
                  vjust = 1,
                  font.label = list(size = 24, colour = "black"))

vol_cap <- "Volcano plots for proteins quantified in EV and WCL. (A) ATCC10231 
            volcano plot. (B) ATCC90028 volcano plot."
```

## Log<sub>2</sub> LFQ intensity heatmap

The `atcc_overall` data.frame is used to construct heatmaps based on the 
proteins that are significantly different across all four samples groups; 
ATCC90028 EV, WCL and ATCC10231 EV, WCL.

There are two type of heatmaps: one for plotting log<sub>2</sub> LFQ intensity 
data and one for plotting log<sub>2</sub> fold change data.To plot an LFQ 
intensity heatmap, a numeric matrix must be used as the input.

In this case the `atcc_overall` data.frame is subset to remove all columns 
except a column with identifiers (e.g. UniProt accessions), 
log2FC data columns, and a logical significance column. Then the data.frame is 
filtered for significant proteins, the UniProt accession column is converted to 
rownames, the significance column is dropped, and the data.frame is converted 
to a matrix.

```{r lfqHeatmapData, echo=TRUE}
# get data for log2 LFQ intensity heatmap
atcc_htmp <- atcc_overall %>% 
  select(UP_accession, 
         matches("A9_EV[0-9]"), matches("A1_EV[0-9]"), 
         matches("A9_W[0-9]"), matches("A1_W[0-9]"),  
         significant) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()
```

The heatmap is plotted with: 
```{r, echo=TRUE, eval=FALSE}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(atcc_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right",
             cluster_split = TRUE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)
```

```{r lfqHeatmap, fig.cap=htmp_cap, fig.height=8}
htmp_params <- list(title = expression("centered"~log[2]~"LFQ intensity"), 
                    color_bar = "continuous", 
                    direction = "vertical", 
                    legend_height = unit(10, "cm"), 
                    title_position = "lefttop-rot", 
                    title_gp = grid::gpar(colour = "black", fontsize = 16), 
                    labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                    at = seq(-5, 5, 1))

plot_heatmap(atcc_htmp, 
             plot = TRUE, 
             data_type = "log2intensity", 
             clust_fun = "euclidean", 
             split_type = "kmeans", 
             k = 5, 
             legend_pos = "right",
             cluster_split = TRUE, 
             colour_lims = c(-4,4), 
             row_title_fontsize = 16, 
             col_name_fontsize = 14, 
             heatmap_legend_param = htmp_params)


htmp_cap <- "Protein log<sub>2</sub> LFQ intensity heatmap. Data has been 
             centred around 0."
```

## Log<sub>2</sub> fold change heatmap

To plot a log<sub>2</sub> fold change heatmap, a numeric matrix must be used 
as the input.

In this case the `atcc_overall` data.frame is subset to remove all columns 
except a column with identifiers (e.g. UniProt accessions), 
log2FC data columns, and a logical significance column. Then the data.frame is 
filtered for significant proteins, the UniProt accession column is converted to 
rownames, the significance column is dropped, and the data.frame is converted 
to a matrix.

```{r logfcHeatmapData, echo=TRUE}
atcc_htmp2 <- atcc_overall %>% 
  select(UP_accession, matches("EV.vs.*W"), significant) %>% 
  filter(significant == TRUE) %>% 
  tibble::column_to_rownames(var = "UP_accession") %>% 
  select(-significant) %>% 
  as.matrix()
```

The heatmap is plotted with:

```{r echo=TRUE, eval=FALSE}
htmp2_params <- list(title = expression(bold(log[2]("FC"))), 
                     color_bar = "continuous", 
                     direction = "vertical", 
                     legend_height = unit(10, "cm"), 
                     title_position = "lefttop-rot", 
                     title_gp = grid::gpar(colour = "black", fontsize = 16), 
                     labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                     at = seq(-10, 10, 2))

htmp2 <- plot_heatmap(atcc_htmp2, 
                      plot = TRUE,
                      data_type = "log2fc", 
                      clust_fun = "euclidean", 
                      split_type = "kmeans", 
                      k = 5, 
                      legend_pos = "right", 
                      row_title_fontsize = 16, 
                      col_name_fontsize = 14, 
                      column_names_rot = 45, 
                      heatmap_legend_param = htmp2_params)
```


```{r logfcHeatmap, fig.cap=htmp2_cap, fig.small=TRUE}
htmp2_params <- list(title = expression(bold(log[2]("FC"))), 
                     color_bar = "continuous", 
                     direction = "vertical", 
                     legend_height = unit(10, "cm"), 
                     title_position = "lefttop-rot", 
                     title_gp = grid::gpar(colour = "black", fontsize = 16), 
                     labels_gp = grid::gpar(colour = "black", fontsize = 16), 
                     at = seq(-10, 10, 2))

htmp2 <- plot_heatmap(atcc_htmp2, 
                      plot = TRUE,
                      data_type = "log2fc", 
                      clust_fun = "euclidean", 
                      split_type = "kmeans", 
                      k = 5, 
                      legend_pos = "right", 
                      row_title_fontsize = 16, 
                      col_name_fontsize = 14, 
                      column_names_rot = 45, 
                      heatmap_legend_param = htmp2_params)

htmp2_cap <- "Protein log<sub>2</sub> fold change heatmap."
```


# Session information {-}

The system on which this document was compiled was running 
pandoc v`r rmarkdown::pandoc_version()`. Here is output of 
`sessionInfo()`.

```{r sessionInfo}
sessionInfo()
```
























