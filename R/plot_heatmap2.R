#' Plot a heatmap
#'
#' \code{plot_heatmap} generates a heatmap of all significant proteins.
#'
#' @param mat SummarizedExperiment,
#' Data object for which differentially enriched proteins are annotated
#' (output from \code{test_diff()} and \code{add_rejections()}).
#' @param exd 'contrast' or 'centered',
#' The type of data scaling used for plotting.
#' Either the fold change ('contrast') or
#' the centered log2-intensity ('centered').
#' @param unip Description.
#' @param kmeans Logical(1),
#' Whether or not to perform k-means clustering.
#' @param k Integer(1),
#' Sets the number of k-means clusters.
#' @param col_limit Integer(1),
#' Sets the outer limits of the color scale.
#' @param indicate Character,
#' Sets additional annotation on the top of the heatmap
#' based on columns from the experimental design (colData).
#' Only applicable to type = 'centered'.
#' @param clustering_distance "euclidean", "maximum", "manhattan", "canberra",
#' "binary", "minkowski", "pearson", "spearman", "kendall" or "gower",
#' Function used to calculate clustering distance (for proteins and samples).
#' Based on \code{\link[ComplexHeatmap]{Heatmap}}
#' and \code{\link[cluster]{daisy}}.
#' @param row_font_size Integer(1),
#' Sets the size of row labels.
#' @param col_font_size Integer(1),
#' Sets the size of column labels.
#' @param plot Logical(1),
#' If \code{TRUE} (default) the heatmap is produced.
#' Otherwise (if \code{FALSE}), the data which the
#' heatmap is based on are returned.
#' @param ... Additional arguments for Heatmap function as depicted in
#' \code{\link[ComplexHeatmap]{Heatmap}}
#' @return A heatmap (generated by \code{\link[ComplexHeatmap]{Heatmap}})
#' @examples
#' # Load example
#' data <- UbiLength
#' data <- data[data$Reverse != "+" & data$Potential.contaminant != "+",]
#' data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
#'
#' # Make SummarizedExperiment
#' columns <- grep("LFQ.", colnames(data_unique))
#' exp_design <- UbiLength_ExpDesign
#' se <- make_se(data_unique, columns, exp_design)
#'
#' # Filter, normalize and impute missing values
#' filt <- filter_missval(se, thr = 0)
#' norm <- normalize_vsn(filt)
#' imputed <- impute(norm, fun = "MinProb", q = 0.01)
#'
#' # Test for differentially expressed proteins
#' diff <- test_diff(imputed, "control", "Ctrl")
#' dep <- add_rejections(diff, alpha = 0.05, lfc = 1)
#'
#' # Plot heatmap
#' plot_heatmap(dep)
#' plot_heatmap(dep, 'centered', kmeans = TRUE, k = 6, row_font_size = 3)
#' plot_heatmap(dep, 'contrast', col_limit = 10, row_font_size = 3)
#' @export
plot_heatmap2 <- function(mat, exd, unip,
                          kmeans = FALSE, k = 6,
                          col_limit = 6, indicate = NULL,
                          clustering_distance = c("euclidean", "maximum", "manhattan", "canberra",
                                                  "binary", "minkowski", "pearson", "spearman", "kendall", "gower"),
                          row_font_size = 6, col_font_size = 10, plot = TRUE, ...) {

  # Show error if inputs are not the required classes
  if(is.integer(k)) k <- as.numeric(k)
  if(is.integer(col_limit)) col_limit <- as.numeric(col_limit)
  if(is.integer(row_font_size)) row_font_size <- as.numeric(row_font_size)
  if(is.integer(col_font_size)) col_font_size <- as.numeric(col_font_size)
  assertthat::assert_that(is.matrix(mat),
                          is.data.frame(exd),
                          assert_exd(exd),
                          is.logical(kmeans),
                          is.numeric(k),
                          length(k) == 1,
                          is.numeric(col_limit),
                          length(col_limit) == 1,
                          is.numeric(row_font_size),
                          length(row_font_size) == 1,
                          is.numeric(col_font_size),
                          length(col_font_size) == 1,
                          is.logical(plot),
                          length(plot) == 1)

  # Show error if inputs do not contain required columns
  # Show error if unip does not contain required columns
  #
  clustering_distance <- match.arg(clustering_distance)

  # Internal function to get ComplexHeatmap::HeatmapAnnotation object
  get_annotation2 <- function(mat, exd, indicate) {
    assertthat::assert_that(
      is.matrix(mat),
      is.data.frame(exd),
      assert_exd(exd),
      is.character(indicate))

    # Check indicate columns
    col_data <- exd %>%
      dplyr::filter(ID %in% colnames(mat))
    columns <- colnames(col_data)
    if(all(!indicate %in% columns)) {
      stop("'",
           paste0(indicate, collapse = "' and/or '"),
           "' column(s) is/are not present in ",
           deparse(substitute(exd)),
           ".\nValid columns are: '",
           paste(columns, collapse = "', '"),
           "'.",
           call. = FALSE)
    }
    if(any(!indicate %in% columns)) {
      indicate <- indicate[indicate %in% columns]
      warning("Only used the following indicate column(s): '",
              paste0(indicate, collapse = "', '"),
              "'")
    }

    # Get annotation
    anno <- dplyr::select(col_data, indicate)

    # Annotation color
    names <- colnames(anno)
    anno_col <- vector(mode="list", length=length(names))
    names(anno_col) <- names
    for(i in names) {
      var = anno[[i]] %>% unique() %>% sort()
      if(length(var) == 1)
        cols <- c("black")
      if(length(var) == 2)
        cols <- c("orangered", "cornflowerblue")
      if(length(var) < 7 & length(var) > 2)
        cols <- RColorBrewer::brewer.pal(length(var), "Pastel1")
      if(length(var) > 7)
        cols <- RColorBrewer::brewer.pal(length(var), "Set3")
      names(cols) <- var
      anno_col[[i]] <-  cols
    }

    # HeatmapAnnotation object
    ComplexHeatmap::HeatmapAnnotation(df = anno,
                                      col = anno_col,
                                      show_annotation_name = TRUE)
  }

  # Extract row and col data
  row_data <- mat
  col_data <- exd

  # Show error if inputs do not contain required columns
  if(any(!c("label", "condition", "replicate") %in% colnames(col_data))) {
    stop(paste0("'label', 'condition' and/or 'replicate' columns are not present in '",
                deparse(substitute(exd)), "'"),
         call. = FALSE)
  }
  if(length(grep("logFC", colnames(row_data))) < 1) {
    stop(paste0("'logFC' columns are not present in '",
                deparse(substitute(mat)),
                "'.\nRun test_diff() to obtain the required columns."),
         call. = FALSE)
  }
  if(!"significant" %in% colnames(row_data)) {
    stop(paste0("'significant' column is not present in '",
                deparse(substitute(mat)),
                "'.\nRun add_rejections() to obtain the required column."),
         call. = FALSE)
  }

  # Heatmap annotation
  if(!is.null(indicate)) {
    ha1 <- get_annotation2(mat, exd, indicate)
  } else {
    ha1 <- NULL
  }

  # Filter for significant proteins only
  filtered <- mat %>%
    as.data.frame() %>%
    tibble::rownames_to_column(var = "UP_accession") %>%
    dplyr::mutate(gn = match_id(.[["UP_accession"]], unip, "UP_accession", "CGD_gene_name")) %>%
    tidyr::drop_na() %>%
    dplyr::filter(significant == 1) %>%
    dplyr::select(gn, dplyr::matches("EV.*"), dplyr::matches("W.*")) %>%
    tibble::column_to_rownames(var = "gn")

  # Check for missing values
  if(any(is.na(filtered))) {
    warning("Missing values in '", deparse(substitute(mat)), "'. ",
            "Using clustering_distance = 'gower'",
            call. = FALSE)
    clustering_distance <- "gower"
    obs_NA <- TRUE
  } else {
    obs_NA <- FALSE
  }

  # Get centered intensity values ('centered')
  mn <- filtered
  mn$mean <- rowMeans(mn, na.rm = TRUE)
  df <- filtered - mn$mean

  # Facultative kmeans clustering
  if(kmeans & obs_NA) {
    warning("Cannot perform kmeans clustering with missing values",
            call. = FALSE)
    kmeans <- FALSE
  }
  if(kmeans & !obs_NA) {
    set.seed(1)
    df_kmeans <- kmeans(df, k)
    # Order the k-means clusters according to the maximum fold change
    # in all samples averaged over the proteins in the cluster
    order <- data.frame(df) %>%
      cbind(., cluster = df_kmeans$cluster) %>%
      dplyr::mutate(row = apply(.[, seq_len(ncol(.) - 1)], 1, function(x) max(x))) %>%
      dplyr::group_by(cluster) %>%
      dplyr::summarise(index = sum(row)/dplyr::n()) %>%
      dplyr::arrange(dplyr::desc(index)) %>%
      dplyr::pull(cluster) %>%
      match(seq_len(k), .)
    df_kmeans$cluster <- order[df_kmeans$cluster]
  }

  if(ncol(df) == 1) {
    col_clust = FALSE
  } else {
    col_clust = TRUE
  }
  if(nrow(df) == 1) {
    row_clust = FALSE
  } else {
    row_clust = TRUE
  }
  if(clustering_distance == "gower") {
    clustering_distance <- function(x) {
      dist <- cluster::daisy(x, metric = "gower")
      dist[is.na(dist)] <- max(dist, na.rm = TRUE)
      return(dist)
    }
  }

  # Legend info
  legend <- "log2 Fold change"

  # Heatmap
  ht1 = ComplexHeatmap::Heatmap(df,
                                col = circlize::colorRamp2(
                                  seq(-col_limit, col_limit, (col_limit/5)),
                                  rev(RColorBrewer::brewer.pal(11, "RdBu"))),
                                split = if(kmeans) {df_kmeans$cluster} else {NULL},
                                cluster_rows = col_clust,
                                cluster_columns = row_clust,
                                row_names_side = "left",
                                column_names_side = "top",
                                clustering_distance_rows = clustering_distance,
                                clustering_distance_columns = clustering_distance,
                                heatmap_legend_param = list(color_bar = "continuous",
                                                            legend_direction = "horizontal",
                                                            legend_width = grid::unit(5, "cm"),
                                                            title_position = "lefttop"),
                                name = legend,
                                row_names_gp = grid::gpar(fontsize = row_font_size),
                                column_names_gp = grid::gpar(fontsize = col_font_size),
                                top_annotation = ha1,
                ...)
  if(plot) {
    # Plot
    ComplexHeatmap::draw(ht1, heatmap_legend_side = "top")
  } else {
    # Return data.frame
    colnames(df) <- gsub(" ", "_", colnames(df))
    df <- df[, unlist(ComplexHeatmap::column_order(ht1))]
    if(kmeans) {
      df <- cbind(df, k = df_kmeans$cluster)
    }
    df[unlist(ComplexHeatmap::row_order(ht1)),] %>%
      tibble::rownames_to_column(var = "gene_name") %>%
      as.data.frame() %>%
      dplyr::mutate(order = dplyr::row_number())
  }
}
